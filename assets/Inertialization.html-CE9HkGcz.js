import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as e,a as n,o as a}from"./app-Cnm-SUPg.js";const t={};function o(r,i){return a(),e("div",null,i[0]||(i[0]=[n(`<h1 id="inertialization" tabindex="-1"><a class="header-anchor" href="#inertialization"><span>Inertialization</span></a></h1><p>在Unreal Engine（UE）中，<strong>Inertialization</strong>（惯性化）是一种动画过渡技术，用于在不同动画状态之间实现平滑的过渡，避免突兀的切换。它通过模拟物理惯性效果，使角色的动作过渡更加自然流畅。</p><h2 id="简介" tabindex="-1"><a class="header-anchor" href="#简介"><span>简介</span></a></h2><h3 id="什么是inertialization" tabindex="-1"><a class="header-anchor" href="#什么是inertialization"><span>什么是Inertialization？</span></a></h3><p>Inertialization 是 UE 动画系统中的一种过渡机制，主要用于在两个动画状态之间进行插值。传统的动画过渡通常使用线性插值（Lerp）或混合（Blend），但这些方法可能会导致动作不连贯或僵硬。Inertialization 通过模拟物理惯性，使得过渡更加平滑，尤其是在快速切换动画状态时。</p><h3 id="为什么需要inertialization" tabindex="-1"><a class="header-anchor" href="#为什么需要inertialization"><span>为什么需要Inertialization？</span></a></h3><p>在角色动画中，动画状态之间的切换非常频繁。例如，角色从跑步切换到站立，或者从跳跃切换到落地。如果直接切换动画，可能会导致角色的姿势或速度突变，看起来不自然。Inertialization 通过保留前一动画的惯性（如速度、旋转等），使过渡更加平滑。</p><h3 id="inertialization-的工作原理" tabindex="-1"><a class="header-anchor" href="#inertialization-的工作原理"><span>Inertialization 的工作原理</span></a></h3><p>Inertialization 的核心思想是：在动画切换时，保留前一动画的某些物理属性（如速度、角速度等），并将其应用到新动画的初始状态中。具体步骤如下：</p><ul><li><strong>检测动画切换</strong>：当动画状态发生变化时，系统会检测前一动画的状态。</li><li><strong>计算惯性</strong>：根据前一动画的速度、旋转等属性，计算出惯性值。</li><li><strong>应用惯性</strong>：将惯性值应用到新动画的初始状态，使过渡更加平滑。</li><li><strong>衰减惯性</strong>：随着时间的推移，惯性效果逐渐衰减，直到完全过渡到新动画。</li></ul><h3 id="inertialization-的优点" tabindex="-1"><a class="header-anchor" href="#inertialization-的优点"><span>Inertialization 的优点</span></a></h3><ul><li><strong>平滑过渡</strong>：避免了动画切换时的突兀感，使动作更加自然。</li><li><strong>减少人工调整</strong>：传统动画过渡需要手动调整混合时间或曲线，而 Inertialization 可以自动处理。</li><li><strong>适用于复杂动画</strong>：特别适合快速切换的复杂动画状态，如战斗、运动等。</li></ul><h3 id="如何在-ue-中使用-inertialization" tabindex="-1"><a class="header-anchor" href="#如何在-ue-中使用-inertialization"><span>如何在 UE 中使用 Inertialization？</span></a></h3><p>在 UE 中，Inertialization 默认集成在动画蓝图中。你可以通过以下方式启用或调整它：</p><ul><li><strong>动画蓝图</strong>：在动画蓝图中，Inertialization 通常会自动应用于状态机中的过渡。你可以通过调整过渡设置来控制惯性效果。</li><li><strong>细节面板</strong>：在动画蓝图的过渡节点中，可以找到与 Inertialization 相关的参数，如惯性时间、衰减速度等。</li></ul><h3 id="示例场景" tabindex="-1"><a class="header-anchor" href="#示例场景"><span>示例场景</span></a></h3><p>假设角色从跑步切换到站立：</p><ul><li>传统方法：直接切换到站立动画，可能会导致角色突然停止，看起来不自然。</li><li>Inertialization：系统会保留跑步时的速度惯性，使角色逐渐减速并过渡到站立状态，看起来更加真实。</li></ul><h3 id="注意事项" tabindex="-1"><a class="header-anchor" href="#注意事项"><span>注意事项</span></a></h3><ul><li><strong>性能开销</strong>：Inertialization 需要计算惯性值，可能会增加一定的性能开销。</li><li><strong>参数调整</strong>：需要根据具体动画调整惯性时间和衰减速度，以达到最佳效果。</li><li><strong>不适合所有场景</strong>：某些动画切换（如瞬间的姿势变化）可能不需要惯性化。</li></ul><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span>总结</span></a></h3><p>Inertialization 是 UE 中一种强大的动画过渡技术，通过模拟物理惯性，使动画切换更加平滑自然。它特别适合需要频繁切换动画状态的场景，如角色运动、战斗等。通过合理使用 Inertialization，可以显著提升动画的表现力和真实感。</p><h2 id="原理" tabindex="-1"><a class="header-anchor" href="#原理"><span>原理</span></a></h2><h3 id="calcinertialfloat" tabindex="-1"><a class="header-anchor" href="#calcinertialfloat"><span>CalcInertialFloat</span></a></h3><p>其核心算法在AnimNode_Inertialization.cpp中的：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp" data-title="cpp"><pre><code><span class="line"><span class="token keyword">static</span> <span class="token keyword">float</span> <span class="token function">CalcInertialFloat</span><span class="token punctuation">(</span><span class="token keyword">float</span> x0<span class="token punctuation">,</span> <span class="token keyword">float</span> v0<span class="token punctuation">,</span> <span class="token keyword">float</span> t<span class="token punctuation">,</span> <span class="token keyword">float</span> t1<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>这段代码实现了一个用于计算“惯性化”（inertialized）浮点数值的函数 <code>CalcInertialFloat</code>。该函数通过一个五次多项式曲线（quintic polynomial curve）来模拟一个物理系统中的惯性运动，确保在给定的时间内平滑地过渡到零值，并且在结束时速度（一阶导数）和加速度（二阶导数）也为零。</p><h3 id="函数参数" tabindex="-1"><a class="header-anchor" href="#函数参数"><span>函数参数</span></a></h3><ul><li><code>x0</code>: 初始值（时间 t=0 时的值）。</li><li><code>v0</code>: 初始速度（时间 t=0 时的一阶导数）。</li><li><code>t</code>: 当前时间，用于计算惯性化值。</li><li><code>t1</code>: 惯性化结束时间，即曲线在该时间点必须为零。</li></ul><h3 id="函数逻辑" tabindex="-1"><a class="header-anchor" href="#函数逻辑"><span>函数逻辑</span></a></h3><ol><li><p><strong>时间边界检查</strong>:</p><ul><li>如果 <code>t</code> 小于 0，将其设置为 0。</li><li>如果 <code>t</code> 接近或超过 <code>t1</code>，直接返回 0，因为此时曲线已经结束。</li></ul></li><li><p><strong>符号处理</strong>:</p><ul><li>如果 <code>x0</code> 为负值，将其取反，并相应地调整 <code>v0</code> 和最终结果的符号。</li></ul></li><li><p><strong>速度限制</strong>:</p><ul><li>如果 <code>v0</code> 为正，将其设置为 0，以防止曲线在过渡过程中出现“过冲”（overshoot）。</li></ul></li><li><p><strong>输入有效性检查</strong>:</p><ul><li>确保 <code>x0</code>、<code>v0</code>、<code>t</code> 和 <code>t1</code> 都是有效的非负值。如果无效，将所有值重置为 0。</li></ul></li><li><p><strong>调整结束时间 <code>t1</code></strong>:</p><ul><li>如果 <code>v0</code> 为负且较大，调整 <code>t1</code> 以确保曲线不会在过渡过程中出现负值（即确保 <code>x &gt;= 0</code> 对于所有 <code>t</code> 在 0 到 <code>t1</code> 之间）。</li></ul></li><li><p><strong>计算初始加速度 <code>a0</code></strong>:</p><ul><li>计算一个初始加速度 <code>a0</code>，使得曲线在 <code>t1</code> 时速度、加速度和加加速度（jerk，三阶导数）都为零。如果计算出的 <code>a0</code> 为负，则将其设置为 0。</li></ul></li><li><p><strong>计算多项式系数</strong>:</p><ul><li>根据初始条件和结束条件，计算五次多项式的系数 <code>A</code>、<code>B</code>、<code>C</code> 和 <code>D</code>。</li></ul></li><li><p><strong>计算当前值 <code>x</code></strong>:</p><ul><li>使用计算出的多项式系数和当前时间 <code>t</code>，计算当前的值 <code>x</code>。</li></ul></li><li><p><strong>返回结果</strong>:</p><ul><li>根据之前的符号处理，返回最终的惯性化值。</li></ul></li></ol><h3 id="关键点" tabindex="-1"><a class="header-anchor" href="#关键点"><span>关键点</span></a></h3><ul><li><strong>五次多项式</strong>：使用五次多项式可以确保曲线在结束时不仅值为零，而且速度和加速度也为零，从而实现平滑的过渡。</li><li><strong>防止过冲</strong>：通过调整 <code>t1</code> 和限制 <code>v0</code>，确保曲线在过渡过程中不会出现负值。</li><li><strong>初始加速度 <code>a0</code></strong>：通过计算一个合适的初始加速度，确保曲线在结束时满足所有条件。</li></ul><h3 id="应用场景" tabindex="-1"><a class="header-anchor" href="#应用场景"><span>应用场景</span></a></h3><p>这种惯性化技术常用于动画、物理模拟和控制系统，用于平滑地过渡到目标值，避免突然的变化和不连续性。例如，在游戏开发中，角色的运动或摄像机的移动可以使用这种技术来实现平滑的过渡效果。</p><h3 id="代码中的数学" tabindex="-1"><a class="header-anchor" href="#代码中的数学"><span>代码中的数学</span></a></h3><p>代码中使用了大量的数学推导和多项式计算，确保曲线在给定的初始条件和结束条件下平滑过渡。这些计算通常通过符号计算工具（如 Mathematica）进行推导，然后在代码中实现。</p><h3 id="总结-1" tabindex="-1"><a class="header-anchor" href="#总结-1"><span>总结</span></a></h3><p><code>CalcInertialFloat</code> 函数通过一个精心设计的五次多项式曲线，实现了从初始值到零值的平滑过渡，确保在结束时速度和加速度也为零。这种技术在需要平滑过渡的场景中非常有用，尤其是在动画和物理模拟中。</p><p>五次多项式（Quintic Polynomial）是指最高次项为五次的多项式函数，通常表示为：</p><p>[ P(t) = At^5 + Bt^4 + Ct^3 + Dt^2 + Et + F ]</p><p>其中，(A, B, C, D, E, F) 是多项式的系数，(t) 是自变量（通常是时间）。</p><hr><h3 id="五次多项式的特点" tabindex="-1"><a class="header-anchor" href="#五次多项式的特点"><span>五次多项式的特点</span></a></h3><ol><li><p><strong>高阶平滑性</strong>：</p><ul><li>五次多项式是一个高阶函数，具有连续的一阶、二阶、三阶甚至更高阶导数。</li><li>这种平滑性使得它在需要高度控制的场景中非常有用，例如动画、机器人路径规划、物理模拟等。</li></ul></li><li><p><strong>灵活性</strong>：</p><ul><li>五次多项式有六个系数（(A, B, C, D, E, F)），因此可以通过六个独立的约束条件来确定这些系数。</li><li>例如，可以指定函数在起点和终点的值、速度（一阶导数）、加速度（二阶导数）等。</li></ul></li><li><p><strong>无振荡性</strong>：</p><ul><li>相比于低阶多项式（如三次多项式），五次多项式更容易避免振荡（overshoot 或 undershoot），尤其是在需要满足多个边界条件时。</li></ul></li></ol><hr><h3 id="为什么使用五次多项式" tabindex="-1"><a class="header-anchor" href="#为什么使用五次多项式"><span>为什么使用五次多项式？</span></a></h3><p>在惯性化（Inertialization）或平滑过渡的场景中，五次多项式被广泛使用，因为它可以满足以下条件：</p><ol><li><strong>位置约束</strong>：指定起点和终点的值（例如，从 (x_0) 过渡到 0）。</li><li><strong>速度约束</strong>：指定起点和终点的速度（例如，起点速度为 (v_0)，终点速度为 0）。</li><li><strong>加速度约束</strong>：指定起点和终点的加速度（例如，起点加速度为 (a_0)，终点加速度为 0）。</li><li><strong>加加速度约束</strong>：如果需要，还可以指定起点和终点的加加速度（jerk，三阶导数）。</li></ol><p>通过五次多项式，可以同时满足这些约束条件，从而实现平滑且可控的过渡。</p><hr><h3 id="五次多项式的应用" tabindex="-1"><a class="header-anchor" href="#五次多项式的应用"><span>五次多项式的应用</span></a></h3><ol><li><p><strong>动画和游戏开发</strong>：</p><ul><li>在角色动画或摄像机移动中，使用五次多项式可以实现平滑的起始和停止，避免突然的跳动或不连续性。</li></ul></li><li><p><strong>机器人路径规划</strong>：</p><ul><li>在机器人控制中，五次多项式可以用于生成平滑的运动轨迹，确保机器人的位置、速度和加速度都满足要求。</li></ul></li><li><p><strong>物理模拟</strong>：</p><ul><li>在物理引擎中，使用五次多项式可以模拟物体的惯性运动，确保运动在结束时平滑停止。</li></ul></li><li><p><strong>控制系统</strong>：</p><ul><li>在控制系统中，五次多项式可以用于设计平滑的控制信号，避免系统的剧烈振荡或不稳定。</li></ul></li></ol><hr><h3 id="示例-惯性化中的五次多项式" tabindex="-1"><a class="header-anchor" href="#示例-惯性化中的五次多项式"><span>示例：惯性化中的五次多项式</span></a></h3><p>在 <code>CalcInertialFloat</code> 函数中，五次多项式的形式为：</p><p>[ x(t) = At^5 + Bt^4 + Ct^3 + Dt^2 + v_0 t + x_0 ]</p><p>其中：</p><ul><li>(x_0) 是初始位置（(t=0) 时的值）。</li><li>(v_0) 是初始速度（(t=0) 时的一阶导数）。</li><li>(A, B, C, D) 是通过边界条件计算出的系数。</li></ul><p>通过以下约束条件确定系数：</p><ol><li>终点位置为零：(x(t_1) = 0)。</li><li>终点速度为零：(v(t_1) = 0)。</li><li>终点加速度为零：(a(t_1) = 0)。</li><li>初始加速度为 (a_0)：(a(0) = a_0)。</li></ol><p>这些约束条件可以通过解方程组来确定系数 (A, B, C, D)。</p><hr><h3 id="总结-2" tabindex="-1"><a class="header-anchor" href="#总结-2"><span>总结</span></a></h3><p>五次多项式是一个高阶平滑函数，具有高度的灵活性和可控性。它能够同时满足位置、速度、加速度甚至更高阶导数的约束条件，因此在需要平滑过渡和精确控制的场景中非常有用。在 <code>CalcInertialFloat</code> 函数中，五次多项式被用来实现从初始值到零值的平滑过渡，同时确保速度和加速度在结束时也为零。</p><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><ul><li><a href="https://www.youtube.com/watch?v=BYyv4KTegJI&amp;t=1210s" target="_blank" rel="noopener noreferrer">Inertialization: High-Performance Animation Transitions in Gears of War </a></li><li>https://zhuanlan.zhihu.com/p/390476167</li><li>https://www.gamer.ne.jp/news/202009030009/</li><li>https://www.gdcvault.com/play/1025331/Inertialization</li><li>https://www.gdcvault.com/play/1025165/Inertialization</li></ul>`,67)]))}const d=l(t,[["render",o],["__file","Inertialization.html.vue"]]),p=JSON.parse('{"path":"/GameEngine/Unreal/animation/Inertialization.html","title":"Inertialization","lang":"en-US","frontmatter":{},"headers":[{"level":2,"title":"简介","slug":"简介","link":"#简介","children":[{"level":3,"title":"什么是Inertialization？","slug":"什么是inertialization","link":"#什么是inertialization","children":[]},{"level":3,"title":"为什么需要Inertialization？","slug":"为什么需要inertialization","link":"#为什么需要inertialization","children":[]},{"level":3,"title":"Inertialization 的工作原理","slug":"inertialization-的工作原理","link":"#inertialization-的工作原理","children":[]},{"level":3,"title":"Inertialization 的优点","slug":"inertialization-的优点","link":"#inertialization-的优点","children":[]},{"level":3,"title":"如何在 UE 中使用 Inertialization？","slug":"如何在-ue-中使用-inertialization","link":"#如何在-ue-中使用-inertialization","children":[]},{"level":3,"title":"示例场景","slug":"示例场景","link":"#示例场景","children":[]},{"level":3,"title":"注意事项","slug":"注意事项","link":"#注意事项","children":[]},{"level":3,"title":"总结","slug":"总结","link":"#总结","children":[]}]},{"level":2,"title":"原理","slug":"原理","link":"#原理","children":[{"level":3,"title":"CalcInertialFloat","slug":"calcinertialfloat","link":"#calcinertialfloat","children":[]},{"level":3,"title":"函数参数","slug":"函数参数","link":"#函数参数","children":[]},{"level":3,"title":"函数逻辑","slug":"函数逻辑","link":"#函数逻辑","children":[]},{"level":3,"title":"关键点","slug":"关键点","link":"#关键点","children":[]},{"level":3,"title":"应用场景","slug":"应用场景","link":"#应用场景","children":[]},{"level":3,"title":"代码中的数学","slug":"代码中的数学","link":"#代码中的数学","children":[]},{"level":3,"title":"总结","slug":"总结-1","link":"#总结-1","children":[]},{"level":3,"title":"五次多项式的特点","slug":"五次多项式的特点","link":"#五次多项式的特点","children":[]},{"level":3,"title":"为什么使用五次多项式？","slug":"为什么使用五次多项式","link":"#为什么使用五次多项式","children":[]},{"level":3,"title":"五次多项式的应用","slug":"五次多项式的应用","link":"#五次多项式的应用","children":[]},{"level":3,"title":"示例：惯性化中的五次多项式","slug":"示例-惯性化中的五次多项式","link":"#示例-惯性化中的五次多项式","children":[]},{"level":3,"title":"总结","slug":"总结-2","link":"#总结-2","children":[]}]},{"level":2,"title":"Reference","slug":"reference","link":"#reference","children":[]}],"git":{"createdTime":1739460897000,"updatedTime":1739460897000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":1}]},"readingTime":{"minutes":9.14,"words":2743},"filePathRelative":"GameEngine/Unreal/animation/Inertialization.md","localizedDate":"February 13, 2025","excerpt":"\\n<p>在Unreal Engine（UE）中，<strong>Inertialization</strong>（惯性化）是一种动画过渡技术，用于在不同动画状态之间实现平滑的过渡，避免突兀的切换。它通过模拟物理惯性效果，使角色的动作过渡更加自然流畅。</p>\\n<h2>简介</h2>\\n<h3>什么是Inertialization？</h3>\\n<p>Inertialization 是 UE 动画系统中的一种过渡机制，主要用于在两个动画状态之间进行插值。传统的动画过渡通常使用线性插值（Lerp）或混合（Blend），但这些方法可能会导致动作不连贯或僵硬。Inertialization 通过模拟物理惯性，使得过渡更加平滑，尤其是在快速切换动画状态时。</p>"}');export{d as comp,p as data};
