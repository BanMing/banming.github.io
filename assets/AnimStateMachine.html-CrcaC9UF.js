import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e,f as i,o as t}from"./app-BCCf93ku.js";const o="/assets/2025-04-24-23-24-03-DDb7T1bX.png",c="/assets/2025-04-24-23-26-47-CNMNZ_nY.png",s="/assets/2025-04-24-23-26-14-c7jFWzss.png",m="/assets/2025-04-24-23-29-54-DqUQmql-.png",l="/assets/2025-04-24-23-30-53-DbYoQgZB.png",r="/assets/2025-04-24-23-32-28-5dFmDx1Y.png",p="/assets/2025-04-24-23-34-40-DkGVHVLD.png",d="/assets/2025-04-24-23-33-28-pDm3ehvM.png",g="/assets/2025-04-24-23-35-29-ftfeC8uR.png",h="/assets/2025-04-21-22-35-08-xTKeaqza.png",f="/assets/2025-04-21-22-56-24-BcO_Lt9Z.png",_={};function b(u,a){return t(),e("div",null,a[0]||(a[0]=[i('<h1 id="animation-state-machine-for-gameplay" tabindex="-1"><a class="header-anchor" href="#animation-state-machine-for-gameplay"><span>Animation State Machine For Gameplay</span></a></h1><p>在做玩法时，经常会有一个需求根据角色当前的播的动画触发一些特殊规则。</p><p>比如角色在待机状态下和行走状态下他的相机的FOV不同，最先想到的使用动画通知来制作该需求，在两个动画中配置对应的FOV设置再应用即可。如果这样的需求多起来，就会有很多动画通知。</p><p>那如果想要做变化值的插值、或者处于该动画时，需要实时检查一些东西、该动画结束后需要做一些操作。这样自然就会想到把播放该动画作为一个状态。</p><p>正常来说角色的locomotion是使用的动画蓝图中的状态机来实现，那可以将这个状态机作为基础，对动画中的状态添加一个对应控制Gameplay的状态。</p><h2 id="如何使用" tabindex="-1"><a class="header-anchor" href="#如何使用"><span>如何使用</span></a></h2><p>这里使用官方的<code>Mannequins</code>资源包中的<code>ABP_Manny</code>作为例子：</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里有两个状态机：</p><ul><li>Main States <br> <img src="'+c+'" alt="" loading="lazy"></li><li>Locomotion <br><img src="'+s+'" alt="" loading="lazy"></li></ul><p>每个状态机都可以对应一个<code>AnimStateMachine</code>，每个状态都可以对应一个<code>AnimState</code>。当然也可以不一一对应。</p><p>创建对应状态机步骤：</p><ul><li>创建<code>AnimStateMachineContainer</code> <br><img src="'+m+'" alt="" loading="lazy"></li><li>将<code>AnimStateMachineContainer</code>配置到<code>AnimInsatance</code> <br><img src="'+l+'" alt="" loading="lazy"></li><li>创建<code>Locomotion</code>状态和状态机 <br><img src="'+r+'" alt="" loading="lazy"></li><li>配置状态 <br> <img src="'+p+'" alt="" loading="lazy"></li><li>创建<code>Main States</code>状态和状态机 <br><img src="'+d+'" alt="" loading="lazy"></li><li>配置状态 <br> <img src="'+g+'" alt="" loading="lazy"></li></ul><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>值得注意的是：<code>AnimState</code>中的<code>StateName</code>需要和<code>AnimInstance</code>中的状态名字一模一样。同理<code>AnimStateMachine</code>的<code>MachineName</code>也必须和<code>AnimInstance</code>中的状态机名字一模一样。</p></div><h2 id="实现" tabindex="-1"><a class="header-anchor" href="#实现"><span>实现</span></a></h2><p><strong>核心逻辑：监听动画蓝图中的<code>FAnimNode_StateMachine</code>信息，通过状态的名字来链接到Gameplay的状态。由动画蓝图的<code>NativePostEvaluateAnimation</code>方法来驱动状态机更新，更新状态是通过获取<code>FAnimNode_StateMachine</code>当前状态是什么相对应去切换状态机中的状态。</strong></p><p><a href="https://github.com/BanMing/AnimStateMachine" target="_blank" rel="noopener noreferrer">源码</a></p><h3 id="类图" tabindex="-1"><a class="header-anchor" href="#类图"><span>类图</span></a></h3><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="时序图" tabindex="-1"><a class="header-anchor" href="#时序图"><span>时序图</span></a></h3><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',21)]))}const S=n(_,[["render",b],["__file","AnimStateMachine.html.vue"]]),x=JSON.parse('{"path":"/GameEngine/Unreal/animation/AnimStateMachine.html","title":"Animation State Machine For Gameplay","lang":"en-US","frontmatter":{"date":"2025-04-21T18:57:03.000Z","tag":["Unreal Engine","Animation"]},"git":{"createdTime":1745247544000,"updatedTime":1745509317000,"contributors":[{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":2,"url":"https://github.com/BanMing"},{"name":"ban-ming@foxmail.com","username":"ban-ming@foxmail.com","email":"ban-ming@foxmail.com","commits":1,"url":"https://github.com/ban-ming@foxmail.com"}]},"readingTime":{"minutes":1.89,"words":567},"filePathRelative":"GameEngine/Unreal/animation/AnimStateMachine.md","localizedDate":"April 21, 2025","excerpt":"\\n<p>在做玩法时，经常会有一个需求根据角色当前的播的动画触发一些特殊规则。</p>\\n<p>比如角色在待机状态下和行走状态下他的相机的FOV不同，最先想到的使用动画通知来制作该需求，在两个动画中配置对应的FOV设置再应用即可。如果这样的需求多起来，就会有很多动画通知。</p>\\n<p>那如果想要做变化值的插值、或者处于该动画时，需要实时检查一些东西、该动画结束后需要做一些操作。这样自然就会想到把播放该动画作为一个状态。</p>\\n<p>正常来说角色的locomotion是使用的动画蓝图中的状态机来实现，那可以将这个状态机作为基础，对动画中的状态添加一个对应控制Gameplay的状态。</p>\\n<h2>如何使用</h2>"}');export{S as comp,x as data};
