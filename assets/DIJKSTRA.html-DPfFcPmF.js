import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as a,f as e,o as p}from"./app-CGgKf99E.js";const o="/assets/20211110221436-j0jLyGHJ.png",t="/assets/20211110233651-CXkYT_T9.png",i="/assets/20211111001740-C-UT3UFg.png",c="/assets/20211111003651-cVOnC7u5.png",l="/assets/20211111004733-DIhTQOwL.png",d="/assets/20211113164606-4wFkqDT_.png",r={};function u(m,n){return p(),a("div",null,n[0]||(n[0]=[e('<h1 id="dijkstra" tabindex="-1"><a class="header-anchor" href="#dijkstra"><span>DIJKSTRA</span></a></h1><p>这个算法最开始设计出来并不是用来解决游戏中的寻路问题，而是来解决数学图形原理叫做<code>最短路径</code>。</p><p>这个方法一般在游戏寻路开发中使用的比较少，因为他是需要找到从开始点到结束点的所有路径，然后筛选出最短路径，这样做非常的浪费。</p><p>但是这是一个简单版本的<code>A*</code>算法，可以让我们更加容易的去理解<code>A*</code>。</p><h2 id="the-problem" tabindex="-1"><a class="header-anchor" href="#the-problem"><span>The Problem</span></a></h2><p>我们需要找到一个最短路径，从开始点到目标点。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="the-algorithm" tabindex="-1"><a class="header-anchor" href="#the-algorithm"><span>The Algorithm</span></a></h2><p>粗略的概括这个算法就是，从起始节点根据它的连接线开始扩张。当它扩张的后面的节点时，我们需要记录下来，它是怎么来到这个节点的，我们可以反向画一个箭头，从当前节点指向上一个节点。这样我们就可以得到一个从前节点到当起始点的路径。最终我们到达目标节点，此时的路径就是我们所求得最短路径。</p><h3 id="processing-the-current-node" tabindex="-1"><a class="header-anchor" href="#processing-the-current-node"><span>Processing the Current Node</span></a></h3><p>这个算法使用迭代器来驱动，每一个迭代器记录着一个节点信息和连接这个节点的所有连接信息。</p><p>节点信息中有：上一个节点到节点的连接信息，从起始点到节点所有的花销</p><p>连接信息中有：头节点，尾节点和花销。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在上图中，对于第一个迭代器，开始节点就是当前节点。也就是说对于所有<code>A</code>点的连接的尾节点的总共花销就是对应每个连接的花销。</p><figure><img src="'+i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在上图中，当前节点是<code>B</code>时，<code>B</code>的每个连接的尾节点的总共花销等于当前连接的花销加上<code>B</code>节点的总共花销。</p><p>即：<code>E</code>的总共花销 = <code>B</code>到<code>E</code>的花销 + <code>B</code>节点的总共花销</p><h3 id="the-node-lists" tabindex="-1"><a class="header-anchor" href="#the-node-lists"><span>The Node Lists</span></a></h3><p>我们使用两个列表来记录已经被发现的节点：</p><ul><li>open ：已经发现了的节点，并未遍历到的节点（未处理的节点），我们在处理当前节点时，当前节点所有连接的尾节点都应该属于open列表里。</li><li>closed ：已经遍历过的节点（处理过的节点）。</li></ul><p>在一张图中，所有的节点只有三种状态：</p><ul><li>被发现的节点，还未遍历</li><li>已经遍历过的节点</li><li>未被发现的节点</li></ul><h3 id="calculating-cost-so-far-for-open-and-closed-nodes" tabindex="-1"><a class="header-anchor" href="#calculating-cost-so-far-for-open-and-closed-nodes"><span>Calculating Cost-So-Far for Open and Closed Nodes</span></a></h3><p>当我们计算尾节点的总共花销时，尾节点如果已经是被发现的节点，那么这个尾节点他是具有总共花销值的。我们就需要比较以当前节点做连接的总共花销小还是之前的总共花销小，如果之前的花销小，那么我们就跳过当前尾节点，反之我们就需要更新尾节点的数据。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图中，在最开始，我们就设置<code>A</code>-&gt;<code>D</code>的花销为3.3。当我遍历到<code>C</code>点时，计算<code>C</code>的尾节点<code>D</code>的总共花销等于连接<code>VI</code>的花销加上<code>C</code>的总共花销，也就是1.3+1.6=2.9。这个数值显然小于之前的3.3，所以我们需要更新<code>D</code>节点的迭代数据。</p><h3 id="terminating-the-algorithm" tabindex="-1"><a class="header-anchor" href="#terminating-the-algorithm"><span>Terminating the Algorithm</span></a></h3><p>当open列表里没有值时，这个算法就结束了，这时已经计算过从起始点到图中所有节点的路径，且所有节点都在closed列表里。</p><p>对于寻路，我们只关心到达目标节点，所以我们可以更早的结束遍历。</p><p>当前节点是目标节点时，我们就可以停止迭代。</p><p>但是很多时候，我们会在发现目标节点时，就停止迭代，即使我们获得的路径不是最短。因为在实际应用中最短的距离与发现目标节点时的那个路径差距并不大，所花去的时间差不多。</p><h3 id="retrieving-the-path" tabindex="-1"><a class="header-anchor" href="#retrieving-the-path"><span>Retrieving the Path</span></a></h3><figure><img src="'+l+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如上图，我们找到目标点<code>G</code>后，我们回溯<code>G</code>点的连接，再让他倒序即可获得路径。</p><h2 id="pseudo-code" tabindex="-1"><a class="header-anchor" href="#pseudo-code"><span>Pseudo-Code</span></a></h2><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token comment"># This structure is used to keep track of the information we need</span></span>
<span class="line"><span class="token comment"># for each node.</span></span>
<span class="line"><span class="token keyword">class</span> <span class="token class-name">NodeRecord</span><span class="token punctuation">:</span></span>
<span class="line">    node<span class="token punctuation">:</span> Node</span>
<span class="line">    connection<span class="token punctuation">:</span> Connection</span>
<span class="line">    costSoFar<span class="token punctuation">:</span> <span class="token builtin">float</span></span>
<span class="line">    </span>
<span class="line">function pathfindDijkstra<span class="token punctuation">(</span>graph<span class="token punctuation">:</span> Graph<span class="token punctuation">,</span> start<span class="token punctuation">:</span> Node<span class="token punctuation">,</span> end<span class="token punctuation">:</span> Node<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Connection<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span></span>
<span class="line">    <span class="token comment"># Initialize the record for the start node.</span></span>
<span class="line">    startRecord <span class="token operator">=</span> new NodeRecord<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    startRecord<span class="token punctuation">.</span>node <span class="token operator">=</span> start</span>
<span class="line">    startRecord<span class="token punctuation">.</span>connection <span class="token operator">=</span> null</span>
<span class="line">    startRecord<span class="token punctuation">.</span>costSoFar <span class="token operator">=</span> <span class="token number">0</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment"># Initialize the open and closed lists.</span></span>
<span class="line">    <span class="token builtin">open</span> <span class="token operator">=</span> new PathfindingList<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token builtin">open</span> <span class="token operator">+=</span> startRecord</span>
<span class="line">    closed <span class="token operator">=</span> new PathfindingList<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment"># Iterate through processing each node.</span></span>
<span class="line">    <span class="token keyword">while</span> length<span class="token punctuation">(</span><span class="token builtin">open</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token comment"># Find the smallest element in the open list.</span></span>
<span class="line">        current<span class="token punctuation">:</span> NodeRecord <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">.</span>smallestElement<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment"># If it is the goal node, then terminate.</span></span>
<span class="line">        <span class="token keyword">if</span> current<span class="token punctuation">.</span>node <span class="token operator">==</span> goal<span class="token punctuation">:</span></span>
<span class="line">            <span class="token keyword">break</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment"># Otherwise get its outgoing connections.</span></span>
<span class="line">        connections <span class="token operator">=</span> graph<span class="token punctuation">.</span>getConnections<span class="token punctuation">(</span>current<span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">        <span class="token comment"># Loop through each connection in turn.</span></span>
<span class="line">        <span class="token keyword">for</span> connection <span class="token keyword">in</span> connections<span class="token punctuation">:</span></span>
<span class="line">            <span class="token comment"># Get the cost estimate for the end node.</span></span>
<span class="line">            endNode <span class="token operator">=</span> connection<span class="token punctuation">.</span>getToNode<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">            endNodeCost <span class="token operator">=</span> current<span class="token punctuation">.</span>costSoFar <span class="token operator">+</span> connection<span class="token punctuation">.</span>getCost<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment"># Skip if the node is closed.</span></span>
<span class="line">            <span class="token keyword">if</span> closed<span class="token punctuation">.</span>contains<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">                <span class="token keyword">continue</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment"># .. or if it is open and we’ve found a worse route.</span></span>
<span class="line">            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token builtin">open</span><span class="token punctuation">.</span>contains<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">                <span class="token comment"># Here we find the record in the open list</span></span>
<span class="line">                <span class="token comment"># corresponding to the endNode.</span></span>
<span class="line">                endNodeRecord <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">.</span>find<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span></span>
<span class="line">            <span class="token keyword">if</span> endNodeRecord<span class="token punctuation">.</span>cost <span class="token operator">&lt;=</span> endNodeCost<span class="token punctuation">:</span></span>
<span class="line">                <span class="token keyword">continue</span></span>
<span class="line"></span>
<span class="line">            <span class="token comment"># Otherwise we know we’ve got an unvisited node, so make a</span></span>
<span class="line">            <span class="token comment"># record for it.</span></span>
<span class="line">            <span class="token keyword">else</span><span class="token punctuation">:</span></span>
<span class="line">                endNodeRecord <span class="token operator">=</span> new NodeRecord<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">                endNodeRecord<span class="token punctuation">.</span>node <span class="token operator">=</span> endNode</span>
<span class="line"></span>
<span class="line">            <span class="token comment"># We’re here if we need to update the node. Update the</span></span>
<span class="line">            <span class="token comment"># cost and connection.</span></span>
<span class="line">            endNodeRecord<span class="token punctuation">.</span>cost <span class="token operator">=</span> endNodeCost</span>
<span class="line">            endNodeRecord<span class="token punctuation">.</span>connection <span class="token operator">=</span> connection</span>
<span class="line"></span>
<span class="line">            <span class="token comment"># And add it to the open list.</span></span>
<span class="line">            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">open</span><span class="token punctuation">.</span>contains<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span><span class="token punctuation">:</span></span>
<span class="line">                <span class="token builtin">open</span> <span class="token operator">+=</span> endNodeRecord</span>
<span class="line"></span>
<span class="line">    <span class="token comment"># We’ve finished looking at the connections for the current</span></span>
<span class="line">    <span class="token comment"># node, so add it to the closed list and remove it from the</span></span>
<span class="line">    <span class="token comment"># open list.</span></span>
<span class="line">    <span class="token builtin">open</span> <span class="token operator">-=</span> current</span>
<span class="line">    closed <span class="token operator">+=</span> current</span>
<span class="line"></span>
<span class="line">    <span class="token comment"># We’re here if we’ve either found the goal, or if we’ve no more</span></span>
<span class="line">    <span class="token comment"># nodes to search, find which.</span></span>
<span class="line">    <span class="token keyword">if</span> current<span class="token punctuation">.</span>node <span class="token operator">!=</span> goal<span class="token punctuation">:</span></span>
<span class="line">        <span class="token comment"># We’ve run out of nodes without finding the goal, so there’s</span></span>
<span class="line">        <span class="token comment"># no solution.</span></span>
<span class="line">        <span class="token keyword">return</span> null</span>
<span class="line"></span>
<span class="line">    <span class="token keyword">else</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token comment"># Compile the list of connections in the path.</span></span>
<span class="line">        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span></span>
<span class="line"></span>
<span class="line">     <span class="token comment"># Work back along the path, accumulating connections.</span></span>
<span class="line">    <span class="token keyword">while</span> current<span class="token punctuation">.</span>node <span class="token operator">!=</span> start<span class="token punctuation">:</span></span>
<span class="line">        path <span class="token operator">+=</span> current<span class="token punctuation">.</span>connection</span>
<span class="line">        current <span class="token operator">=</span> current<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>getFromNode<span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span>
<span class="line">    <span class="token comment"># Reverse the path, and return it.</span></span>
<span class="line">    <span class="token keyword">return</span> reverse<span class="token punctuation">(</span>path<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="data-structures-and-interfaces" tabindex="-1"><a class="header-anchor" href="#data-structures-and-interfaces"><span>Data Structures and Interfaces</span></a></h2><h3 id="simple-list" tabindex="-1"><a class="header-anchor" href="#simple-list"><span>Simple List</span></a></h3><p>用来存储最后找到的路径，可以使用链表(<code>std::list</code>)或者变长数组(<code>std::vector</code>)</p><h3 id="pathfinding-list" tabindex="-1"><a class="header-anchor" href="#pathfinding-list"><span>Pathfinding List</span></a></h3><p>用来存储<code>open</code>和<code>close</code>列表，这两个列表对该算法非常重要，这直接关系到算法效率的好坏。这个列表主要有4个操作：</p><ol><li>添加节点到列表</li><li>从列表中移除移除节点</li><li>找到最小的花销的节点</li><li>找到列表中中特殊的节点</li></ol><p>我们需要合理的找到一个数据结构来使用，我们会在<code>A*</code>的章节来详细讲解一下这些数据结构。</p><h3 id="graph" tabindex="-1"><a class="header-anchor" href="#graph"><span>Graph</span></a></h3><p>我们在前面的实现也可以看到图的一些接口。</p><p>其中<code>getConnections</code>是最重要的一个方法，同时也是对性能影响至关重要。最常见的实现是：有一个存储的查询表并且使用节点的索引来查询。一个索引对应的是一个连接的数组。</p><p>连接的数据结构大概是这样的：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line"><span class="token keyword">class</span> <span class="token class-name">Connection</span><span class="token punctuation">:</span></span>
<span class="line">    cost<span class="token punctuation">:</span> <span class="token builtin">float</span></span>
<span class="line">    fromNode<span class="token punctuation">:</span> Node</span>
<span class="line">    toNode<span class="token punctuation">:</span> Node</span>
<span class="line"></span>
<span class="line">    function getCost<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">float</span><span class="token punctuation">:</span></span>
<span class="line">        <span class="token keyword">return</span> cost</span>
<span class="line"></span>
<span class="line">    function getFromNode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Node<span class="token punctuation">:</span></span>
<span class="line">        <span class="token keyword">return</span> fromNode</span>
<span class="line"></span>
<span class="line">    function getToNode<span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Node<span class="token punctuation">:</span></span>
<span class="line">        <span class="token keyword">return</span> toNode</span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="peformance-of-dijkstra" tabindex="-1"><a class="header-anchor" href="#peformance-of-dijkstra"><span>Peformance of Dijkstra</span></a></h2><p>该算法在内存和速度最大的依赖是操作寻路列表的数据结构，也就是<code>open</code>和<code>close</code>列表。</p><p>图中所有节点的个数为<code>n</code>，平均每个节点的连接数为<code>m</code>。那么这个算法的时间复杂度为<code>O(nm)</code>。</p><p>在算法结束时，有<code>n</code>个节点在<code>close</code>列表中，不会有超高<code>nm</code>个节点在<code>open</code>列表中。实际上在<code>open</code>列表里肯定会少于<code>n</code>个。所以最差情况下空间复杂<code>O(nm)</code>。</p><p>加上操作数据结构的时间，最差肯定会超过<code>O(nm)</code>。当然空间复杂度也会超过。</p><h2 id="weaknesses" tabindex="-1"><a class="header-anchor" href="#weaknesses"><span>Weaknesses</span></a></h2><p>该算法最大的劣势是不假选择的搜索整个图来找到最短的路径。</p><p>我们可以通过典型运行在不同阶段显示当前打开和关闭列表上的节点来可视化算法的工作方式。</p><figure><img src="`+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在每种情况下，搜索的边界都由开放列表上的节点组成。因为靠近开始点已经被处理过了。</p><p>可以看到最后一个图，找到了最短路径，也就是那根线。同时也发现了有很多离那根线很远的点，我们也处理了。这也增加了很多计算时间。</p><p>我们需要有选择性的去处理节点。</p>',61)]))}const h=s(r,[["render",u],["__file","DIJKSTRA.html.vue"]]),b=JSON.parse('{"path":"/Gameplay/AI/PathFinding/DIJKSTRA.html","title":"DIJKSTRA","lang":"en-US","frontmatter":{"date":"2020-09-10T22:45:25.000Z","tag":["Game AI"]},"git":{"createdTime":1599749125000,"updatedTime":1707213711000,"contributors":[{"name":"BanMing","username":"BanMing","email":"banming729@163.com","commits":1,"url":"https://github.com/BanMing"},{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":9,"url":"https://github.com/BanMing"},{"name":"wupeng","username":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2,"url":"https://github.com/wupeng"}]},"readingTime":{"minutes":6.73,"words":2020},"filePathRelative":"Gameplay/AI/PathFinding/DIJKSTRA.md","localizedDate":"September 10, 2020","excerpt":"\\n<p>这个算法最开始设计出来并不是用来解决游戏中的寻路问题，而是来解决数学图形原理叫做<code>最短路径</code>。</p>\\n<p>这个方法一般在游戏寻路开发中使用的比较少，因为他是需要找到从开始点到结束点的所有路径，然后筛选出最短路径，这样做非常的浪费。</p>\\n<p>但是这是一个简单版本的<code>A*</code>算法，可以让我们更加容易的去理解<code>A*</code>。</p>\\n<h2>The Problem</h2>\\n<p>我们需要找到一个最短路径，从开始点到目标点。</p>\\n<figure><figcaption></figcaption></figure>\\n<h2>The Algorithm</h2>"}');export{h as comp,b as data};
