import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as a,f as e,o as t}from"./app-DFTNGWD6.js";const p={};function i(c,n){return t(),a("div",null,n[0]||(n[0]=[e(`<h1 id="scritping-strategies" tabindex="-1"><a class="header-anchor" href="#scritping-strategies"><span>Scritping Strategies</span></a></h1><h2 id="obtaining-components-using-the-fastest-mehod" tabindex="-1"><a class="header-anchor" href="#obtaining-components-using-the-fastest-mehod"><span>Obtaining components using the fastest mehod</span></a></h2><p>最好的方式获得组件：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line"><span class="token generic-method"><span class="token function">GetComponent</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="removing-empty-callback-definitions" tabindex="-1"><a class="header-anchor" href="#removing-empty-callback-definitions"><span>Removing empty callback definitions</span></a></h2><p>移除MonoBehaviour中空的生命周期函数：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnGUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">LateUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">FixedUpdate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>可以使用正则表达式查找：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line"><span class="token keyword">void</span>\\s<span class="token operator">*</span>Update\\s<span class="token operator">*</span><span class="token punctuation">?</span>\\<span class="token punctuation">(</span>s<span class="token operator">*</span><span class="token punctuation">?</span>\\<span class="token punctuation">)</span>\\s<span class="token operator">*</span><span class="token punctuation">?</span>\\n<span class="token operator">*</span><span class="token punctuation">?</span>\\<span class="token punctuation">{</span>\\n<span class="token operator">*</span><span class="token punctuation">?</span>\\s<span class="token operator">*</span><span class="token punctuation">?</span>\\<span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><h2 id="caching-component-referemces" tabindex="-1"><a class="header-anchor" href="#caching-component-referemces"><span>Caching component referemces</span></a></h2><p>使用少量的内存换取CPU的开销。</p><h2 id="shaing-calculation-output" tabindex="-1"><a class="header-anchor" href="#shaing-calculation-output"><span>Shaing calculation output</span></a></h2><p>存放一些可能会公用的计算结果，这样我们就不需要重复计算，如AI中的寻路。</p><h2 id="update-coroutines-and-invokerepeating" tabindex="-1"><a class="header-anchor" href="#update-coroutines-and-invokerepeating"><span>Update,coroutines,and InvokeRepeating</span></a></h2><p>我们在计算一些数据的次数比使用到这些数据的次数多的时候，就需要对update做一定的优化。</p><p>比如：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token function">ProcessAI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>我们可能不需要每一帧去调用这个方法，所以可以使用隔几秒调用。</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line"><span class="token class-name"><span class="token keyword">float</span></span> _delayTime <span class="token operator">=</span> <span class="token number">0.3f</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name"><span class="token keyword">float</span></span> _curTime<span class="token punctuation">;</span></span>
<span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">Update</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    _curTime <span class="token operator">+=</span> Time<span class="token punctuation">.</span>deltaTime<span class="token punctuation">;</span></span>
<span class="line">    <span class="token keyword">if</span><span class="token punctuation">(</span>_curTime <span class="token operator">&gt;</span> _delayTime<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        _curTime <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></span>
<span class="line">        <span class="token function">ProcessAI</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这种做法，就会出现空的<code>Update</code>回调。我们可以使用到另外两种做法：</p><ul><li>Corotines</li><li>InvokeRepeating</li></ul><p>有一个性能测试对比空的<code>Update</code>,<code>Coroutines</code>,<code>InvokeRepeating</code>：</p><ul><li>1000个空的<code>Update</code>的耗时<code>1.1</code>毫秒</li><li>1000个协成使用的<code>WaitForEndOfFrame</code>的耗时是<code>2.9</code>毫秒</li><li>1000个<code>InvokeRepeating</code>的耗时是<code>2.6</code>毫秒</li></ul><p>协成还有很多问题：</p><ul><li>内存开销会大一些</li><li>运行会受到GameObject的激活</li></ul><h2 id="faster-gameobject-null-reference-checks" tabindex="-1"><a class="header-anchor" href="#faster-gameobject-null-reference-checks"><span>Faster GameObject null reference checks</span></a></h2><p>一些不必要的<code>GameObject</code>判空会造成性能的消耗。因为<code>GameObject</code>和<code>Monobehaviours</code>这两个属于是两个特殊的对象，他们在内存中有两种表示形式：一个存在于管理我们编写的C#代码的统一系统所管理的内存中（托管代码），而另一个则单独的操作于不同的内存空间（本地代码）。数据可以在这两个空间之间移动，但是每一次移动会造成额外的CPU消耗和内存的分配。</p><p>我们可以改使用：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span>gameObject <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do stuff with gameObject</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>System<span class="token punctuation">.</span>Object<span class="token punctuation">.</span><span class="token function">ReferenceEquals</span><span class="token punctuation">(</span>gameObject<span class="token punctuation">,</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do stuff with gameObject</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个也可以应该到其他的<code>Unity Objects</code>，这个的影响其实不太大。</p><h2 id="avoid-retrieving-string-properties-from-gameobjects" tabindex="-1"><a class="header-anchor" href="#avoid-retrieving-string-properties-from-gameobjects"><span>Avoid retrieving string properties from GameObjects</span></a></h2><p>不要使用<code>tag</code>和<code>name</code>来判断一个游戏物体这会造成多余的内存分配。我们可以通过组件来区分游戏物体。<br> 如果一定要是使用<code>tag</code>我们可以使用<code>CompareTag</code>这个方法会好一些。</p><h2 id="using-appropriate-data-structures" tabindex="-1"><a class="header-anchor" href="#using-appropriate-data-structures"><span>Using appropriate data structures</span></a></h2><p>字典与列表的区别：</p><ul><li>字典在取和插入时，可以很快。遍历可能就不是那么快，取决于内存分配</li><li>列表恰恰相反</li></ul><h2 id="avoiding-re-parenting-transforms-at-runtime" tabindex="-1"><a class="header-anchor" href="#avoiding-re-parenting-transforms-at-runtime"><span>Avoiding re-parenting transforms at runtime</span></a></h2><p>每个<code>Transform</code>都会有一个层级结构，使用一个列表来存储子物体。若果当前<code>Transform</code>的这个列表长度达到上限了，我们就需要新申请空间。所以说我们可以在游戏物体实例化时就对这个游戏物体的父物体做指定。</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line">GameObject<span class="token punctuation">.</span><span class="token function">Instantiate</span><span class="token punctuation">(</span><span class="token range operator">..</span><span class="token range operator">..</span><span class="token punctuation">,</span>parent<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><p>同样我们也可以早早的定义好没有子物体的游戏物体的<code>Transform.hierarchyCapacity</code></p><h2 id="considering-caching-transform-changes" tabindex="-1"><a class="header-anchor" href="#considering-caching-transform-changes"><span>Considering caching transform changes</span></a></h2><p>有两种优化这里：</p><ul><li>能直接修改<code>local</code>本地的数据就修改本地的数据，这样省去了矩阵的转换，世界坐标到本地坐标</li><li>缓存本地<code>transform</code>的变化，在<code>FixedUpdate</code>中修改。因为在修改<code>transform</code>属性时，会通知其他的组件，这样就会一直通知。</li></ul><h2 id="avoiding-find-and-sendmessage-at-runtime" tabindex="-1"><a class="header-anchor" href="#avoiding-find-and-sendmessage-at-runtime"><span>Avoiding Find() and SendMessage() at runtime</span></a></h2><p>消耗非常之大，我们可以使用一下方案来解决：</p><ul><li>Assign references to preexisting objets：在组件中直接引用其他对象，并在编辑器下对其赋值</li><li>Static classes：构造方法是在第一次调用该类时调用</li><li>Singleton components：file access,downloads,data parsing, and messaging.</li><li>A global messaging system</li></ul><h2 id="disabling-unused-scripts-and-objects" tabindex="-1"><a class="header-anchor" href="#disabling-unused-scripts-and-objects"><span>Disabling unused scripts and objects</span></a></h2><p>场景足够大时，物体多就会导致性能拖拉，我们可以把远处或者不必要的物体或脚本关闭。</p><h3 id="disabling-objects-by-visibility" tabindex="-1"><a class="header-anchor" href="#disabling-objects-by-visibility"><span>Disabling objects by visibility</span></a></h3><p>可以使用两个回调来知道我们的游戏物体是否被相机看到：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnBecameVisible</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>gameObject<span class="token punctuation">.</span><span class="token function">SetActive</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span>
<span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">OnBecameInvisible</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>gameObject<span class="token punctuation">.</span><span class="token function">SetActive</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>但是触发这个回调必须要有<code>Render</code>相关的组件才行，如：<code>Skinned Mesh Renderer</code>,<code>Mesh Renderer</code> 等。</p><h3 id="disabling-objects-by-distance" tabindex="-1"><a class="header-anchor" href="#disabling-objects-by-distance"><span>Disabling objects by distance</span></a></h3><p>距离远的物体可以关闭</p><h2 id="using-distance-squared-over-distance" tabindex="-1"><a class="header-anchor" href="#using-distance-squared-over-distance"><span>Using distance-squared over distance</span></a></h2><p>使用开方消耗极大，我们使用<code>sqrMagnitude</code>来代替，例如：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs"><pre><code><span class="line"><span class="token class-name"><span class="token keyword">float</span></span> distanceSqrd <span class="token operator">=</span> <span class="token punctuation">(</span>transform<span class="token punctuation">.</span>position <span class="token operator">-</span> other<span class="token punctuation">.</span>transform<span class="token punctuation">.</span>position<span class="token punctuation">)</span><span class="token punctuation">.</span>sqrMagnitude<span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span><span class="token punctuation">(</span>distanceSqrd <span class="token operator">&lt;</span> <span class="token punctuation">(</span>targetDistance <span class="token operator">*</span> targetDistance<span class="token punctuation">)</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token comment">// do studff</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="minimizing-deserialization-behavior" tabindex="-1"><a class="header-anchor" href="#minimizing-deserialization-behavior"><span>Minimizing deserialization behavior</span></a></h2><p>Unity的序列化系统主要是场景，预制件，ScriptableObjects和各种资源类型。它们是以文本文件的形式存在磁盘上的，使用一种标记语言的格式存储的（Yet Another Markup Language - YAML），可以反序列化回对象。</p><p>其实反序列化这个过程对性能有一个较大的开销，过程也是相对比较慢。比如说一个预制件拥有很深的层级，预制件有很多空的GameObject，并且每一个GameObject至少有一个Transform的组件。这种情况最多出现在UI的预制件中。</p><p>加载一个大预制件时，可能会造成CPU的峰值，同时也增加了加载时间。更重要的是，它会引起帧率下降。</p><h3 id="reducing-serialized-object-size" tabindex="-1"><a class="header-anchor" href="#reducing-serialized-object-size"><span>Reducing serialized object size</span></a></h3><p>我们的目标应该是使序列化的对象尽可能小，或者将他们分割成更小的数据块，后面使用时，可以把他们组合起来。</p><h3 id="loading-serialized-objects-asynchronously" tabindex="-1"><a class="header-anchor" href="#loading-serialized-objects-asynchronously"><span>Loading serialized objects asynchronously</span></a></h3><p>这对于游戏开始就需要使用到的物体，不太适用于异步加载。</p><h3 id="keeping-previously-loaded-serialized-objects-in-memory" tabindex="-1"><a class="header-anchor" href="#keeping-previously-loaded-serialized-objects-in-memory"><span>Keeping previously loaded serialized objects in memory</span></a></h3><h3 id="moving-common-data-into-scriptableobjects" tabindex="-1"><a class="header-anchor" href="#moving-common-data-into-scriptableobjects"><span>Moving common data into ScriptableObjects</span></a></h3><p>直接使用这个可以节省反序列化后的赋值。</p><h2 id="loading-scenes-additively-and-async-hronously" tabindex="-1"><a class="header-anchor" href="#loading-scenes-additively-and-async-hronously"><span>Loading scenes additively and async hronously</span></a></h2><h2 id="creating-a-custom-update-layer" tabindex="-1"><a class="header-anchor" href="#creating-a-custom-update-layer"><span>Creating a custom Update() layer</span></a></h2><p>使用一个Update方法代替多个Update方法，编写一个OnUpdate的接口，然后把所有继承该接口的对象，都放在唯一的一个Update中去调用。</p>`,70)]))}const r=s(p,[["render",i],["__file","scripting.html.vue"]]),d=JSON.parse('{"path":"/GameEngine/Unity/manual/optimize/scripting.html","title":"Scritping Strategies","lang":"en-US","frontmatter":{"date":"2022-07-22T14:08:55.000Z","tag":["Unity","Optimization","C#"]},"git":{"createdTime":1658470135000,"updatedTime":1707213711000,"contributors":[{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":4,"url":"https://github.com/BanMing"},{"name":"wupeng","username":"wupeng","email":"ban-ming@foxmail.com","commits":1,"url":"https://github.com/wupeng"},{"name":"wupeng","username":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2,"url":"https://github.com/wupeng"}]},"readingTime":{"minutes":4.81,"words":1443},"filePathRelative":"GameEngine/Unity/manual/optimize/scripting.md","localizedDate":"July 22, 2022","excerpt":"\\n<h2>Obtaining components using the fastest mehod</h2>\\n<p>最好的方式获得组件：</p>\\n<div class=\\"language-csharp line-numbers-mode\\" data-highlighter=\\"prismjs\\" data-ext=\\"cs\\"><pre><code><span class=\\"line\\"><span class=\\"token generic-method\\"><span class=\\"token function\\">GetComponent</span><span class=\\"token generic class-name\\"><span class=\\"token punctuation\\">&lt;</span>T<span class=\\"token punctuation\\">&gt;</span></span></span><span class=\\"token punctuation\\">(</span><span class=\\"token punctuation\\">)</span></span>\\n<span class=\\"line\\"></span></code></pre>\\n<div class=\\"line-numbers\\" aria-hidden=\\"true\\" style=\\"counter-reset:line-number 0\\"><div class=\\"line-number\\"></div></div></div>"}');export{r as comp,d as data};
