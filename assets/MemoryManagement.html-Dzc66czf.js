import{_ as s}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as a,a as e,o as t}from"./app-BCDbMlfn.js";const p="/assets/36698321_51-zNezgD9z.jpg",l={};function o(i,n){return t(),a("div",null,n[0]||(n[0]=[e('<h1 id="masterful-memory-management" tabindex="-1"><a class="header-anchor" href="#masterful-memory-management"><span>Masterful Memory Management</span></a></h1><h2 id="overview-of-the-mono-platform" tabindex="-1"><a class="header-anchor" href="#overview-of-the-mono-platform"><span>Overview of the Mono platform</span></a></h2><p>C#为托管语言，也就是托管代码，意思是他是运行在通用语言运行（CLR）环境中的，而不是编译他到指定的操作系统中去运行。</p><h3 id="native-and-managed-memory-domains" tabindex="-1"><a class="header-anchor" href="#native-and-managed-memory-domains"><span>Native and managed memory domains</span></a></h3><p>Unity 有三个内存分区：</p><ul><li>The managed domain: 托管分区，也就是Mono使用到的那部分，这里会使用垃圾收集（GC）来自动管理</li><li>The native domain: 原生分区，也就是内置的一些系统，如声音，贴图，物理这些，是由c++使用的。</li><li>The external libraries：外部库，如图形：DirectX 和 OpenGL。</li></ul><p>托管区域还有一个就是原生区和托管区之间的交互，在交互时，需要一定的内存空间来处理，这可能会对我们的游戏造成相当大的性能影响。</p><h3 id="the-statck" tabindex="-1"><a class="header-anchor" href="#the-statck"><span>The statck</span></a></h3><p>栈是内存中一个特殊空间，分配给小的，短生命周期的数据，这些数据会自动回收当他们离开他们所在的范围时。这些数据都存在栈的数据结构中，读取和存储的方式就是后进后出。</p><p>栈包含了我们声明的任何局部变量，并在调用函数时处理函数的加载和卸载。这些函数调用通过所谓的调用栈进行扩展和收缩。当调用栈完成当前函数时，它将跳回到调用栈上的前一点，并从他停止的地方继续。</p><p>前一个内存分配的开始总是已知的，没有理由执行任何清理操作，因为任何新的分配可以简单地覆盖旧的数据。因此，栈是相对快速和有效的。</p><p>栈一般很小，通常是MB。造成栈溢出一般都是分配空间超过栈的空间：</p><ul><li>异常大的调用栈，如无限循环</li><li>有一个超级大的数字，越界</li></ul><p>尽管栈的规模相对较小，但很少引起栈溢出。</p><h3 id="the-heap" tabindex="-1"><a class="header-anchor" href="#the-heap"><span>The heap</span></a></h3><p>堆表示所有剩余的内存空间，它用于绝大多数内存分配。当我们的需要让一个内存分配更加的持久，我们就需要分配到堆中，还有就是数据类型过大，也是需要分配到堆中。堆和栈在物理上都是在<code>RAM</code>中的。</p><p>在本地代码（如C++）的编写中，我们需要手动对堆内存做管理，申请了堆内存，就一定需要手动释放该内存，不然会造成内存过大或者内存泄露。</p><p>在托管代码中，对于堆内存是通过<code>GC</code>来自动管理。<code>Mono</code>在<code>unity</code>程序启动时，会想操作系统申请一块堆内存空间来给我们写的C#代码使用，也叫做托管堆。堆内存开始会很小，小于1MB。会随着我们在脚本中的使用增加。</p><h3 id="garbage-collection" tabindex="-1"><a class="header-anchor" href="#garbage-collection"><span>Garbage collection</span></a></h3><p>GC可以让我们安全使用托管内存，让一些我们不再使用的对象回收。比如我们在销毁<code>GameObject</code>后，<code>GC</code>会标记那块内存空间，且并不会立即清空该内存空间，会在内存需要时才会清空。</p><p>当申请新的内存时，如果托管内存是足够的，直接分配。反之，就会先触发<code>GC</code>去扫描当前在内存的所有对象，找到那些没有在使用了，并对其清空。</p><p><code>Mono</code>中的<code>GC</code>在<code>Unity</code>中使用的是追踪类型，策略是标记和扫描（<code>Mark-and-Sweep</code>）。这个算法大致的流程如下：</p><ul><li>每分配一个对象时给他一个额外字节，来存储一个标准位，这个标志位代表这该对象是否没标记。这个 标志 开始设置为<code>false</code>，表示尚未标记。当 <code>GC</code>开始时，这个标志会标记为<code>true</code>来表示程序仍然可以访问该对象。</li><li>遍历所有对象，通过标记来判断当前对象的空间是否应该被销毁。把所有未标记的对象都清空他们的空间。</li><li>如果<code>GC</code>后空间足够给新的对象分配，就把空间给新对象。反之，则需要向操作系统申请新的托管堆内存</li></ul><h3 id="memory-fragmentation" tabindex="-1"><a class="header-anchor" href="#memory-fragmentation"><span>Memory fragmentation</span></a></h3><p>所有的对象在清空内存空间时，这个清空顺序肯跟我们在申请时的顺序不同且每个对象使用的空间也不同，所以就会产生内存碎片化的问题。因为内存是连续性的，就会出现一小格空的，然后一大格被占用。这样出现小空格很难分配给新的对象。</p><p><img src="'+p+`" alt="" loading="lazy"> 我们可以简单使用四个步骤来解释这一问题：</p><ul><li>开始有一个空的堆内存空间</li><li>分配4格对象A,B,C,D，每个对象占用64-bytes的大小</li><li>过一段时间A和C释放128-bytes的空间</li><li>这时，我们尝试分配一个新的128-bytes大小的空间。因为A和C释放的空间并不连续，所以我们需要新申请一个空间，不能达到复用的效果。</li></ul><p>这样的话我们就需要等到下一个申请64-bytes大小的空间或者小于时，才能对A或C的空间复用。这就会出现两个问题：</p><ul><li>这造成内存复用率不高。每次都需要<code>GC</code>后发现没有空间适合，就需要新的申请堆内存。</li><li>这会在分配新空间时，花费更多时间去找到适合的内存。</li></ul><p>所以申请新的空间，最坏的结果会让CPU多工作很多步，如下：</p><ul><li>判断当前堆内存是否有一个连续且大小合适的空间给新的对象</li><li>如果没有，遍历所有直接和间接的引用，将它们连接的所有内容标记为可访问</li><li>再次遍历这些引用，标记未标记的对象以进行释放</li><li>遍历所有标记的对象，检查释放其中一些对象是否会为新对象创建足够的连续空间</li><li>如果不能，就需要向操作系统申请新的堆内存块</li><li>然后分配新的空间给新对象</li></ul><p>这对于玩家直接的影响就是游戏会卡顿，比如说一些粒子系统，角色进入一个新的场景。</p><h3 id="threaded-garbage-collection" tabindex="-1"><a class="header-anchor" href="#threaded-garbage-collection"><span>Threaded garbage collection</span></a></h3><p><code>GC</code>一般会执行再两个线程上：</p><ul><li>主线程</li><li>最终调用线程 这过程都不是立即释放内存空间，可能会等几秒</li></ul><h3 id="code-compilation" tabindex="-1"><a class="header-anchor" href="#code-compilation"><span>Code compilation</span></a></h3><p>我们在写了C#代码后，它会被自动的编译到Unity编辑器下。C#并没有直接编译到机器码，不像C++一样使用静态编译器转化为机器码。</p><p>我们的代码被转化为<code>Common Intermediate Language(CIL)</code>，它是机器码之上的抽象。属于是一种中间语言，它和Java的字节码相似，CPU并不能直接运行这个代码。</p><p>在运行是，中间代码运行在Mono的虚拟机上，虚拟机可以使同样的代码运行在不同的平台上。</p><p>在通用语言运行环境中（CLR），中间语言（CIL）是需要编译成本地代码，从而使平台的CPU能够运行编写的指令，这里由两种方式：</p><ul><li>Ahead-Of-Time（AOT）：提前编译，构建时编译或者软件初始化时编译。所以会再运行时快一些。</li><li>Just-In-Time（JIT）：运行时在调用前，在一个独立线程中编译。所以会花一些时间编译，但是一旦编译过后的模块，后续再次调用就不需要再编译。</li></ul><p>JIT编译必须快速，所以无法像静态的AOT编译器一样使用很多优化的方式。Mono有些平台只支持AOT而有些平台只支持JIT，可以查看这个文档：https://docs.unity3d.com/Manual/ScriptingRestrictions.html</p><h3 id="building-a-project-using-il2cpp" tabindex="-1"><a class="header-anchor" href="#building-a-project-using-il2cpp"><span>Building a project using IL2CPP</span></a></h3><p>IL2CPP是一个脚本后台，用于把Mono的CIL转化为对应平台的C++代码。这可以提高运行效率。IL2CPP提供了自带的AOT编译器和一个虚拟机，同时还可以自定义一些子系统，如GC和编译过程。</p><p>Unity选择使用IL2CPP的原因：https://blog.unity.com/technology/the-future-of-scripting-in-unity</p><p>Unity中的IL2CPP具体可以查看文档：https://docs.unity3d.com/Manual/IL2CPP.html</p><h3 id="how-to-profile-memory-issues" tabindex="-1"><a class="header-anchor" href="#how-to-profile-memory-issues"><span>How to profile memory issues</span></a></h3><h2 id="implement-various-memory-related-performance-enhancements" tabindex="-1"><a class="header-anchor" href="#implement-various-memory-related-performance-enhancements"><span>Implement various memory-related performance enhancements</span></a></h2><h3 id="minimizing-garbage-collection" tabindex="-1"><a class="header-anchor" href="#minimizing-garbage-collection"><span>Minimizing garbage collection</span></a></h3><h4 id="profiling-memory-consumption" tabindex="-1"><a class="header-anchor" href="#profiling-memory-consumption"><span>Profiling memory consumption</span></a></h4><p>使用<code>Profiler.GetRuntimeMenorySize()</code>可以获得本地代码分配的内存。 使用<code>Profiler.GetMonoHeapSize()</code>和<code>Profiler.GetMonoUsedSize()</code>获取托管堆中内存大小和托管代码已经使用的代码。</p><h4 id="profiling-memory-efficiency" tabindex="-1"><a class="header-anchor" href="#profiling-memory-efficiency"><span>Profiling memory efficiency</span></a></h4><p>我们衡量内存管理是否是良好时，就去观察GC的行为。GC的运行的次数越多，就会产生更多浪费和性能更加糟糕。</p><h4 id="garbage-collection-tactics" tabindex="-1"><a class="header-anchor" href="#garbage-collection-tactics"><span>Garbage collection tactics</span></a></h4><p>一个最小化垃圾回收问题的策略是在我们确信玩家不会注意到的时候手动调用GC来隐藏垃圾回收。可以使用<code>System.GC.Collect()</code>。</p><p>手动调用这个方法最好的时机，是场景切换，游戏暂停，或者是玩家不经意间。我们也可以使用<code>Profiler.GetMonoUsedSize()</code>和<code>Profiler.GetMonoHeapSize()</code>这两个方法来判断内存的使用程度，来手动调用GC。</p><p>我们也可以让在销毁后需要立即清空内存的对象继承于<code>IDiposable</code>，我们可以强制控制这个对象的内存清空。在Unity引擎中也有很多继承该接口的类型：NetworkConnection，UnityWebRequest，UploadHandler...</p><h4 id="manual-jit-compilation" tabindex="-1"><a class="header-anchor" href="#manual-jit-compilation"><span>Manual JIT compilation</span></a></h4><p>如果JIT编译会导致运行时性能损失，实际上可以通过反射在任何时候强制对方法进行JIT编译。例如：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token class-name"><span class="token keyword">var</span></span> method <span class="token operator">=</span> <span class="token keyword">typeof</span><span class="token punctuation">(</span><span class="token type-expression class-name">MyComponent</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GetMethod</span><span class="token punctuation">(</span><span class="token string">&quot;MethodName&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token keyword">if</span><span class="token punctuation">(</span>method <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    method<span class="token punctuation">.</span>MethodHandle<span class="token punctuation">.</span><span class="token function">GetFunctionPointer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">&quot;JIT compilation complete!&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是反射的使用同样是很消耗性能，所以这种方式能不用就不用。除非我们已经确定说当前性能的问题就是出现在编译上。</p><h3 id="using-value-types-and-reference-types-properly" tabindex="-1"><a class="header-anchor" href="#using-value-types-and-reference-types-properly"><span>Using value types and reference types properly</span></a></h3><p>一般而言，引用类型是分配在堆上，值类型是分配在栈上。但是当一个值类型在一个引用类型内部时，比如一个数组或者一个类，这也暗示着这个类型数据过大对于栈来说，或者需要更长存在时间，所以这种情况下久会被分配到堆内中，与它拥有的引用类型绑定在一起。</p><p>在栈里，旧数据是被新数据覆盖的。并没有新创建数据，所以栈里并不需要GC。</p><p>以下有几个典型的例子：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestComponent</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name"><span class="token keyword">int</span></span> data <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// allocated on the statck</span></span>
<span class="line">        <span class="token function">DoSomething</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token comment">// integer is dealloacted from the stack here</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestComponent</span> <span class="token punctuation">:</span> <span class="token type-list"><span class="token class-name">MonoBehaviour</span></span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name"><span class="token keyword">int</span></span> _data <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span> <span class="token comment">// allocated on the heap, deallocated when the component is destroyed</span></span>
<span class="line">    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token function">DoSomething</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestData</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">public</span> <span class="token class-name"><span class="token keyword">int</span></span> data <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestComponent</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">TestData</span> dataObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TestData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allocated  on the heap</span></span>
<span class="line">        <span class="token function">DoSomething</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span><span class="token comment">// dataObj is not immediately deallocated here</span></span>
<span class="line">     <span class="token comment">// but it will become a candidate during the next GC sweep</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestComponent</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name">TestData</span> _testDataObj<span class="token punctuation">;</span></span>
<span class="line"></span>
<span class="line">    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        <span class="token class-name">TestData</span> dataObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">TestData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// allocated  on the heap</span></span>
<span class="line">        <span class="token function">DoSomething</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line">    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token class-name">TestData</span> dataObj<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        _testDataObj <span class="token operator">=</span> dataObj<span class="token punctuation">;</span><span class="token comment">// a new reference created!</span></span>
<span class="line">        <span class="token comment">// The referenced object will now be marked during Mark-and-Sweep</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TestClass</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token keyword">private</span> <span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> _intArray  <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// Reference type, full of Value types</span></span>
<span class="line"></span>
<span class="line">    <span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">StoreANumber</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">int</span></span> num<span class="token punctuation">)</span></span>
<span class="line">    <span class="token punctuation">{</span></span>
<span class="line">        _intArray<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">=</span> num<span class="token punctuation">;</span> <span class="token comment">// copy a Value</span></span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="pass-by-value-and-by-reference" tabindex="-1"><a class="header-anchor" href="#pass-by-value-and-by-reference"><span>Pass by value and by reference</span></a></h4><p>传递引用只是复制了一个指向值，传递值是需要复制所有值。</p><h4 id="structs-are-value-types" tabindex="-1"><a class="header-anchor" href="#structs-are-value-types"><span>Structs are value types</span></a></h4><p>当一个数据结构比较大时，同时它传递超过5个函数时，我们需要考虑使用<code>ref</code>关键字来减少复制。</p><h4 id="arrays-are-reference-types" tabindex="-1"><a class="header-anchor" href="#arrays-are-reference-types"><span>Arrays are reference types</span></a></h4><p>当我们创建一个引用类型的数据数组时，每个数据真实的值都在堆上，数组中存的只是一个地址。</p><p>当我们创建一个值类型的数据数组时，我们只是把一个值类型的列表打包放在堆上。</p><h3 id="using-strings-responsibly" tabindex="-1"><a class="header-anchor" href="#using-strings-responsibly"><span>Using strings responsibly</span></a></h3><p>字符串是引用类型，但是特殊的是它是不能被修改的，当它被分配后。因为字符串就是字符的数组，这也暗示着他需要一个连续的内存。所以我们在改变一个字符串的值时，是在堆中新申请一个空间，<strong>然后把这空间替换到字符串上去</strong>。所以老的字符串空间就没有被引用到了，这里就会等待GC扫描到它，然后再清理。下面有一个堆字符串特殊性的例子简介：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">TestFunction</span><span class="token punctuation">(</span><span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name"><span class="token keyword">string</span></span> testString <span class="token operator">=</span> <span class="token string">&quot;Hello&quot;</span><span class="token punctuation">;</span></span>
<span class="line">    <span class="token function">DoSomething</span><span class="token punctuation">(</span>testString<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line">    Debug<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span>testString<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span>
<span class="line"><span class="token return-type class-name"><span class="token keyword">void</span></span> <span class="token function">DoSomething</span><span class="token punctuation">(</span><span class="token class-name"><span class="token keyword">string</span></span> localString<span class="token punctuation">)</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    localString <span class="token operator">=</span> <span class="token string">&quot;World&quot;</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里按照引用类型来说，这里输出的是<code>World</code>，但是实际上这里最终输出的是<code>Hello</code>。这就是字符串特殊之处，因为字符串是不可修改的，当我们修改它时，需要新分配一个含有<code>World</code>的字符串。这个值就会替换到<code>localString</code>的值。<code>Hello</code>的字符串的引用数变成了<strong>1</strong>。<code>testString</code>就不会改变。所以最终的输出是<code>Hello</code>。</p><p><code>StringBuilder</code> 是在最开始就是申请一个长的数组，这样来处理字符串就可以不需要新区申请字符串，但是如果字符串过长，超过最开始申请的数组，也是需要新申请的。</p><h3 id="boxing" tabindex="-1"><a class="header-anchor" href="#boxing"><span>Boxing</span></a></h3><p>关于装箱，值得注意的是，把值类型的变量用作引用类型，装箱仅仅是创建了一个外壳来存放这个值类型，这个外壳可以认为是引用类型。这个行为会造成堆内存分配的，所以我们需要尽量避免。</p><h3 id="the-importance-of-data-layout" tabindex="-1"><a class="header-anchor" href="#the-importance-of-data-layout"><span>The importance of data layout</span></a></h3><p>在取数据时，减少查命中失败是一个很好的优化方式，这意味着一系列的数据都在连续的内存中，这样我们在取时就会很快。这同样对GC也很有效果，因为在检测数据时，是需要遍历所有数据的，所以这样在遍历时就更快。本质上来说，我们希望大块的引用类型的数据和大块的值类型的数据分开。就算只有一个引用类型在值类型中，那么这个值类型的所有参数都需要被验证。比如说一个数据结构：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token keyword">public</span> <span class="token keyword">struct</span> <span class="token class-name">MyStruct</span></span>
<span class="line"><span class="token punctuation">{</span></span>
<span class="line">    <span class="token class-name"><span class="token keyword">int</span></span> myInt<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name"><span class="token keyword">float</span></span> myFloat<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name"><span class="token keyword">bool</span></span> myBool<span class="token punctuation">;</span></span>
<span class="line">    <span class="token class-name"><span class="token keyword">string</span></span> myString<span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"><span class="token class-name">MyStruct <span class="token punctuation">[</span><span class="token punctuation">]</span></span> arraryOfStructs <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name">MyStruct</span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里我们就需要额外去检测3000次，也就是那3个基础类型。如果我们换成这样写：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token class-name"><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> myInts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">int</span></span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name"><span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> myFloats <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">float</span></span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name"><span class="token keyword">bool</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> myBoolss <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">bool</span></span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name"><span class="token keyword">string</span><span class="token punctuation">[</span><span class="token punctuation">]</span></span> myStrings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token constructor-invocation class-name"><span class="token keyword">string</span></span><span class="token punctuation">[</span><span class="token number">1000</span><span class="token punctuation">]</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这样的GC就会快于上一种，这里只需要扫描字符串。</p><h3 id="arrays-from-the-unity-api" tabindex="-1"><a class="header-anchor" href="#arrays-from-the-unity-api"><span>Arrays from the Unity API</span></a></h3><p>在unity的API中有的方法也会在堆中分配内存，比如：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token generic-method"><span class="token function">GetComponents</span><span class="token generic class-name"><span class="token punctuation">&lt;</span>T<span class="token punctuation">&gt;</span></span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// (T[])</span></span>
<span class="line">Mesh<span class="token punctuation">.</span>vertices<span class="token punctuation">;</span> <span class="token comment">// (Vector3[])</span></span>
<span class="line">Camera<span class="token punctuation">.</span>allCameras<span class="token punctuation">;</span> <span class="token comment">// (Camera[])</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这些方法我们需要避免调用，最多调用一次即可。</p><h3 id="using-instanceids-for-dictionary-keys" tabindex="-1"><a class="header-anchor" href="#using-instanceids-for-dictionary-keys"><span>Using InstanceIDs for dictionary keys</span></a></h3><p>我们可以使用<code>Object.GetInstanceID()</code>这个方法来区分对象，这种方式在使用<code>Mono</code>时会比<code>IL2CPP</code>的消耗的大一些。因为<code>Mono</code>调用一些线程不安全的方法，同时<code>Mono</code>编译器不会优化循环。</p><h3 id="foreach-loops" tabindex="-1"><a class="header-anchor" href="#foreach-loops"><span>foreach loops</span></a></h3><p>在Unity 2018.1 的版本前使用foreach会造成大量的堆内存分配，在之后的版本就修复。这个问题的核心还是在于<code>GetEnumerator</code>这个方法的实现。现在还是会有堆内存的分配，不过还好，都是复用的<code>Enumerator</code>对于消耗来说是比较小的。全部替换为for循环也是不太好的。</p><h3 id="coroutines" tabindex="-1"><a class="header-anchor" href="#coroutines"><span>Coroutines</span></a></h3><p>在开启一个协成时，会分配小部分内存去启动这个协成。如果内存和GC是一个严重问题对于项目，我们就需要减少使用短周期的协成和调用<code>StartCoroutine</code>很多次。</p><h3 id="closures" tabindex="-1"><a class="header-anchor" href="#closures"><span>Closures</span></a></h3><p>关于闭包和匿名函数的区别如下例子：</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token class-name">System<span class="token punctuation">.</span>Func<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> anon <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> <span class="token function">anon</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>以上这个例子只是单纯的匿名函数，并不是闭包，这个跟正常的本地函数是一样的。</p><div class="language-csharp line-numbers-mode" data-highlighter="prismjs" data-ext="cs" data-title="cs"><pre><code><span class="line"><span class="token class-name"><span class="token keyword">int</span></span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name">System<span class="token punctuation">.</span>Func<span class="token punctuation">&lt;</span><span class="token keyword">int</span><span class="token punctuation">,</span><span class="token keyword">int</span><span class="token punctuation">&gt;</span></span> anon <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token keyword">return</span> x <span class="token operator">+</span> i<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token class-name"><span class="token keyword">int</span></span> result <span class="token operator">=</span> <span class="token function">anon</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span> </span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>以上这个例子就是闭包了，因为在匿名函数中使用了本地变量。编译器会申明一个自定义的类来引用环境以便于可以调用<code>i</code>这个数据，在运行中时，在堆中创建一个对象，这个对象会传递给匿名方法。使用完了也会销毁，所以这里就会造成GC。所以我们一般不使用闭包，使用委托对象来代替。</p><h3 id="the-net-library-functions" tabindex="-1"><a class="header-anchor" href="#the-net-library-functions"><span>The .NET library functions</span></a></h3><p>有两个方法我们应该避免使用<code>LINQ</code>和<code>regular expressions</code>，他们的消耗都挺高的。</p><h3 id="object-and-perfab-pooling" tabindex="-1"><a class="header-anchor" href="#object-and-perfab-pooling"><span>Object and Perfab pooling</span></a></h3><p>可以有三种类型：</p><ul><li>C#对象</li><li>GameObject</li><li>Components</li></ul>`,111)]))}const d=s(l,[["render",o],["__file","MemoryManagement.html.vue"]]),u=JSON.parse('{"path":"/GameEngine/Unity/manual/optimize/MemoryManagement.html","title":"Masterful Memory Management","lang":"en-US","frontmatter":{"date":"2022-07-22T00:10:33.000Z","tag":["Unity","Optimization"]},"headers":[{"level":2,"title":"Overview of the Mono platform","slug":"overview-of-the-mono-platform","link":"#overview-of-the-mono-platform","children":[{"level":3,"title":"Native and managed memory domains","slug":"native-and-managed-memory-domains","link":"#native-and-managed-memory-domains","children":[]},{"level":3,"title":"The statck","slug":"the-statck","link":"#the-statck","children":[]},{"level":3,"title":"The heap","slug":"the-heap","link":"#the-heap","children":[]},{"level":3,"title":"Garbage collection","slug":"garbage-collection","link":"#garbage-collection","children":[]},{"level":3,"title":"Memory fragmentation","slug":"memory-fragmentation","link":"#memory-fragmentation","children":[]},{"level":3,"title":"Threaded garbage collection","slug":"threaded-garbage-collection","link":"#threaded-garbage-collection","children":[]},{"level":3,"title":"Code compilation","slug":"code-compilation","link":"#code-compilation","children":[]},{"level":3,"title":"Building a project using IL2CPP","slug":"building-a-project-using-il2cpp","link":"#building-a-project-using-il2cpp","children":[]},{"level":3,"title":"How to profile memory issues","slug":"how-to-profile-memory-issues","link":"#how-to-profile-memory-issues","children":[]}]},{"level":2,"title":"Implement various memory-related performance enhancements","slug":"implement-various-memory-related-performance-enhancements","link":"#implement-various-memory-related-performance-enhancements","children":[{"level":3,"title":"Minimizing garbage collection","slug":"minimizing-garbage-collection","link":"#minimizing-garbage-collection","children":[]},{"level":3,"title":"Using value types and reference types properly","slug":"using-value-types-and-reference-types-properly","link":"#using-value-types-and-reference-types-properly","children":[]},{"level":3,"title":"Using strings responsibly","slug":"using-strings-responsibly","link":"#using-strings-responsibly","children":[]},{"level":3,"title":"Boxing","slug":"boxing","link":"#boxing","children":[]},{"level":3,"title":"The importance of data layout","slug":"the-importance-of-data-layout","link":"#the-importance-of-data-layout","children":[]},{"level":3,"title":"Arrays from the Unity API","slug":"arrays-from-the-unity-api","link":"#arrays-from-the-unity-api","children":[]},{"level":3,"title":"Using InstanceIDs for dictionary keys","slug":"using-instanceids-for-dictionary-keys","link":"#using-instanceids-for-dictionary-keys","children":[]},{"level":3,"title":"foreach loops","slug":"foreach-loops","link":"#foreach-loops","children":[]},{"level":3,"title":"Coroutines","slug":"coroutines","link":"#coroutines","children":[]},{"level":3,"title":"Closures","slug":"closures","link":"#closures","children":[]},{"level":3,"title":"The .NET library functions","slug":"the-net-library-functions","link":"#the-net-library-functions","children":[]},{"level":3,"title":"Object and Perfab pooling","slug":"object-and-perfab-pooling","link":"#object-and-perfab-pooling","children":[]}]}],"git":{"createdTime":1658419833000,"updatedTime":1707213711000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":3},{"name":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2}]},"readingTime":{"minutes":13.91,"words":4174},"filePathRelative":"GameEngine/Unity/manual/optimize/MemoryManagement.md","localizedDate":"July 22, 2022","excerpt":"\\n<h2>Overview of the Mono platform</h2>\\n<p>C#为托管语言，也就是托管代码，意思是他是运行在通用语言运行（CLR）环境中的，而不是编译他到指定的操作系统中去运行。</p>\\n<h3>Native and managed memory domains</h3>\\n<p>Unity 有三个内存分区：</p>\\n<ul>\\n<li>The managed domain: 托管分区，也就是Mono使用到的那部分，这里会使用垃圾收集（GC）来自动管理</li>\\n<li>The native domain: 原生分区，也就是内置的一些系统，如声音，贴图，物理这些，是由c++使用的。</li>\\n<li>The external libraries：外部库，如图形：DirectX 和 OpenGL。</li>\\n</ul>"}');export{d as comp,u as data};
