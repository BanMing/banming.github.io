import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as i,f as e,o as s}from"./app-DqLLaKe-.js";const t="/assets/20211116211624-JTddDU5I.png",o="/assets/20211116110007-wQHat6Dc.png",p="/assets/20211116214603-D2NWIfh0.png",d="/assets/20211116214651-CadlhB4M.png",c="/assets/20211116230303-DBQdNYCL.png",r="/assets/20211116231131-DlDTARuo.png",l="/assets/20211117000706-SaY9v9nm.png",h="/assets/20211117003933-Diq7-bHT.png",g="/assets/20211117005652-CqdMi3m6.png",u="/assets/20211117011230-CEg7PIcD.png",f="/assets/20211117011339-BwxHW8As.png",m={};function b(z,a){return s(),i("div",null,a[0]||(a[0]=[e(`<h1 id="world-representations" tabindex="-1"><a class="header-anchor" href="#world-representations"><span>World Representations</span></a></h1><p>我们现在知道寻路使用图来解决，但是我们的游戏场景并不是由多个节点和节点的连接组成的。那么我们就需要有游戏场景抽象话。</p><p>抽象场景的方式叫做<code>划分方案（division schemes）</code>,每个划分方案都有三个重要的性质：量化/定位（quantization/localization）、分区（generation）和有效性（validity）</p><h3 id="quantization-and-localization" tabindex="-1"><a class="header-anchor" href="#quantization-and-localization"><span>Quantization and Localization</span></a></h3><p>在游戏中，角色想要去商店，就需要把角色当前的位置转化到图中节点，同样商店的位置也要转化到图中节点。这个转化过程叫做<code>量化（quantization）</code>。</p><p>在找到了去商店的路径后，我们需要把路径中的节点转化为游戏场景中的位置，这个过程叫做<code>定位（localization）</code></p><h3 id="generation" tabindex="-1"><a class="header-anchor" href="#generation"><span>Generation</span></a></h3><p>有很多分区的方法，每个游戏中用到的可能都不太一样。一般分为手动分区和自动分区。</p><p>手动分区最常用的是<code> 狄利克雷分布（Dirichlet domain）</code></p><p>自动分区最常用的的 <code>瓦片地图（tile graphs）</code>，<code>可视化点（points of visibility）</code>和<code> 导航网格（navigation meshes）</code></p><h3 id="validity" tabindex="-1"><a class="header-anchor" href="#validity"><span>Validity</span></a></h3><p>我们寻路得到一个路径了，从节点<code>A</code>到节点<code>B</code>,那么意味着角色无论如何都可以从<code>A</code>点移动到<code>B</code>点，但是如果无法量化<code>A</code>点或者<code>B</code>点的话或者角色不具备通过这个路径中的某个能力（如游泳）。那么这个寻路就是无效的。</p><h2 id="tile-graphs" tabindex="-1"><a class="header-anchor" href="#tile-graphs"><span>Tile Graphs</span></a></h2><p>这种方式一般在2D游戏里使用，多出现在独立游戏里。但是也有很多3D游戏会使用网格在映射游戏。比如很多RTS游戏，在里面建造房子，以格子来设置房子大小以及位置。</p><h3 id="division-scheme" tabindex="-1"><a class="header-anchor" href="#division-scheme"><span>Division Scheme</span></a></h3><p>用网格代表游戏世界。每一个小块一般都是正方形的，换句话说就是棋盘格。每个小块周围有8个小块围绕，与每个小块连接的也就是8个。</p><h3 id="quantization-and-localization-1" tabindex="-1"><a class="header-anchor" href="#quantization-and-localization-1"><span>Quantization and Localization</span></a></h3><p>我们可以很简单的量化角色在那个节点，我们以网格左下角为原点，向上为Z轴，向右为X轴建立坐标系。我们就可以用下面的表达式获得角色节点位置：</p><div class="language-python line-numbers-mode" data-highlighter="prismjs" data-ext="py"><pre><code><span class="line">tileX<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> floor<span class="token punctuation">(</span>x <span class="token operator">/</span> tileSize<span class="token punctuation">)</span></span>
<span class="line">tileZ<span class="token punctuation">:</span> <span class="token builtin">int</span> <span class="token operator">=</span> floor<span class="token punctuation">(</span>z <span class="token operator">/</span> tileSize<span class="token punctuation">)</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>同样定位也可以很容易的做到，反向求一下x和z值就可以。</p><h3 id="generation-1" tabindex="-1"><a class="header-anchor" href="#generation-1"><span>Generation</span></a></h3><p>基本的网络生成一般都是自动的。因为它每一个片基本都是差不多。它可以在游戏运行时生成。</p><h3 id="validity-1" tabindex="-1"><a class="header-anchor" href="#validity-1"><span>Validity</span></a></h3><p>如果有的格子是半格可以走，半格被遮挡住。这种情况就需要在由节点定位到游戏场景位置时，考虑角色是否在那个位置。</p><figure><img src="`+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="usefulness" tabindex="-1"><a class="header-anchor" href="#usefulness"><span>Usefulness</span></a></h3><p>在一个RTS游戏关卡里可能有成千上百的小块，这会使得寻路算法，花销很多。</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从上图可以看到寻路得到的路径和理想上的路径有一定的区别，而且看起来不是那么的丝滑。</p><h2 id="dirichlet-domains" tabindex="-1"><a class="header-anchor" href="#dirichlet-domains"><span>Dirichlet Domains</span></a></h2><h3 id="division-scheme-1" tabindex="-1"><a class="header-anchor" href="#division-scheme-1"><span>Division Scheme</span></a></h3><p>寻路节点在空间中有一个称为特征点的关联点，并且通过将该点的狄利克雷分布的所有位置映射到该节点来进行量化。确定游戏中的一个位置的节点，我们找到了 最接近的特征点。</p><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>你可以把狄利克雷分布看作是来之源点的锥体。如果你从顶部查看它们。你就可以看到每个圆锥体的区域都是属于该源点的区域。这是一个很有用的排除故障的可视化方法。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们可以为点增加一个权重，来调整圆锥的斜率，这样就可以调整么诶个圆锥覆盖的区域。当然也需要注意这关卡编辑时，设置关键点时，他的权重值不能过高。不然就会出现上图的情况。</p><h3 id="quantization-and-localization-2" tabindex="-1"><a class="header-anchor" href="#quantization-and-localization-2"><span>Quantization and Localization</span></a></h3><p>位置通过找到最接近的特征点来量化，节点的定位是由形成分布域的特征点的位置（即 上诉例子中锥的尖端）给出的 。</p><h3 id="validity-2" tabindex="-1"><a class="header-anchor" href="#validity-2"><span>Validity</span></a></h3><p>无法保证从一个域中的一个点移动到 连接域中的某个点不会通过第三个域。这第三个域可能无法逾越，而且可能已经被寻路器忽略了。在这种情况下，遵循该路径将会导致一个问题。有可能角色就撞墙了。</p><p>为了防止这种情况，我们 可以设置某种备份机制（如避免墙上的转向行为），来解决这个问题。</p><h3 id="usefulness-1" tabindex="-1"><a class="header-anchor" href="#usefulness-1"><span>Usefulness</span></a></h3><p>应用非常广泛。它的优点是非常容易编程，并且易于更改。可以在几倍编辑工具中快速更改寻路图的结构，而无需更改任何级别的几何结构。</p><h2 id="points-of-visibility" tabindex="-1"><a class="header-anchor" href="#points-of-visibility"><span>Points of Visibility</span></a></h2><p>在2D环境中最短的路径一般都是会经过转角处。那我们可以把几个转角连接起来就是最短路径了。如果我们移动的角色有半径，那么就从转角点向外偏移直到可以使角色转向过那个转角点。</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="division-scheme-2" tabindex="-1"><a class="header-anchor" href="#division-scheme-2"><span>Division Scheme</span></a></h3><p>我们在连接两个点时，怎么判断两个点 之间是可以通过的呢？我们从其中一个点发射射线，如果这个射线并没有碰撞到其他物体，直接到达了对应点，那么我们就认为这两个点时可以相互走的。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="quantization-and-localization-and-validity" tabindex="-1"><a class="header-anchor" href="#quantization-and-localization-and-validity"><span>Quantization and Localization and Validity</span></a></h3><p>为了量化，通常用课件点来表示狄利克雷域的中心 。此外，如果使用狄利克雷域进行量化，则量化到两个节点的点可能无法相互到达。正如我们在上的狄利克雷域中所看到的，这意味着该图是无效的。</p><h3 id="usefulness-2" tabindex="-1"><a class="header-anchor" href="#usefulness-2"><span>Usefulness</span></a></h3><p>这是一个很好的方案，但是这其中有很多无用的连接，我们需要手动去处理。使用导航网格更好一些。</p><h2 id="navigation-meshes" tabindex="-1"><a class="header-anchor" href="#navigation-meshes"><span>Navigation Meshes</span></a></h2><p>这个是最常用的一个方式。</p><h3 id="division-scheme-3" tabindex="-1"><a class="header-anchor" href="#division-scheme-3"><span>Division Scheme</span></a></h3><p>可以对游戏场景中的地面做了多边形划分区域。对于每个多边形可以认为就是一个节点。如下图所示：</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="quantization-and-localization-3" tabindex="-1"><a class="header-anchor" href="#quantization-and-localization-3"><span>Quantization and Localization</span></a></h3><p>我们做量化时，是不是就需要找到角色现在处于那个多边形内？最容易想到的方式就是遍历所有多边形，如果多边形少还可以，多了的话是不是就会等一会。这里有一种简单的方式，我们会记录下来角色上一帧所在的多边形，我们先检查这个多边形 ，然后以扩张（上一帧多边形周围）的方式来检查。这样可以更快的找到。</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>量化中有一个问题，如果游戏场景有多层的情况。我们划分多边形时，不考虑垂直方向的情况。这就会出现错误。比如：上图，量化看出人物在底层，但是实际上这个人物是在上层的。我们同样可以使用角色上一帧的多边形来确定角色是在上还是下。在一些特殊的情况下使用这样的方式还是会出现一定的问题，通常需要一些特殊的案例代码来知道一个角色何时在跳跃，或者推迟寻径，或者使用轨迹预测来确定它将降落在哪里。</p><p>定位一般是定到多边形的重心位置。当然多边形一定要是凸的。</p><h3 id="validity-3" tabindex="-1"><a class="header-anchor" href="#validity-3"><span>Validity</span></a></h3><p>理论上我们可以中一个区域的任何一个点直接到达相邻区域。</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们看上图，就出现了从一个区域到另一个去区域产生了碰撞的情况。这就是在生成多边形或是设计多边形时的错误。</p><h3 id="usefulness-3" tabindex="-1"><a class="header-anchor" href="#usefulness-3"><span>Usefulness</span></a></h3><p>这是个很好的方案，在一些特殊情况下也可以使用，比如爬墙，跳跃等。</p><p>有一个问题，如果分的区域很小，角色不能容纳进去。就会有一些问题。我们可以在设计时对其限制。</p><h4 id="edges-as-nodes" tabindex="-1"><a class="header-anchor" href="#edges-as-nodes"><span>Edges as Nodes</span></a></h4><p>地面多边形还可以通过将节点分配到多边形的边上，并使用跨多边形的面连接，从而将地板多边形转换为寻路。</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这种方式在渲染中很常用叫做基于块渲染（portal-based rendering）。就是把一个整的几何体，分成多个小块，当我需要那个块时就渲染那块。</p><p>在导航网格中，每个楼层多边形的边缘都像一个块，因此有自己的节点。我们不需要做射线检测。根据定义，凸底多边形的每一条边都可以从其他的每一条边看到。</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如上图，我们也可以把节点在多边形线上的位置改成动态的，改到角色移动的方向。这是一种连续的寻路算法。</p><h2 id="non-translation-problems" tabindex="-1"><a class="header-anchor" href="#non-translation-problems"><span>Non-Translation Problems</span></a></h2><h2 id="cost-functions" tabindex="-1"><a class="header-anchor" href="#cost-functions"><span>Cost Functions</span></a></h2><h2 id="path-smoothing" tabindex="-1"><a class="header-anchor" href="#path-smoothing"><span>Path Smoothing</span></a></h2>',80)]))}const y=n(m,[["render",b],["__file","WorldRepresentation.html.vue"]]),_=JSON.parse('{"path":"/Gameplay/AI/PathFinding/WorldRepresentation.html","title":"World Representations","lang":"en-US","frontmatter":{"date":"2021-11-17T01:35:21.000Z","tag":["Game AI"]},"git":{"createdTime":1637084121000,"updatedTime":1707213711000,"contributors":[{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":3,"url":"https://github.com/BanMing"},{"name":"wupeng","username":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2,"url":"https://github.com/wupeng"}]},"readingTime":{"minutes":7.65,"words":2295},"filePathRelative":"Gameplay/AI/PathFinding/WorldRepresentation.md","localizedDate":"November 17, 2021","excerpt":"\\n<p>我们现在知道寻路使用图来解决，但是我们的游戏场景并不是由多个节点和节点的连接组成的。那么我们就需要有游戏场景抽象话。</p>\\n<p>抽象场景的方式叫做<code>划分方案（division schemes）</code>,每个划分方案都有三个重要的性质：量化/定位（quantization/localization）、分区（generation）和有效性（validity）</p>\\n<h3>Quantization and Localization</h3>\\n<p>在游戏中，角色想要去商店，就需要把角色当前的位置转化到图中节点，同样商店的位置也要转化到图中节点。这个转化过程叫做<code>量化（quantization）</code>。</p>"}');export{y as comp,_ as data};
