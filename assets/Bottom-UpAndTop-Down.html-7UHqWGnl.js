import{_ as t}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as d,c as a,e}from"./app-U_EQjXEx.js";const r={},i=e('<h1 id="自底向上与自顶向下的区别" tabindex="-1"><a class="header-anchor" href="#自底向上与自顶向下的区别" aria-hidden="true">#</a> 自底向上与自顶向下的区别</h1><h2 id="自顶向下模型" tabindex="-1"><a class="header-anchor" href="#自顶向下模型" aria-hidden="true">#</a> 自顶向下模型</h2><p>在这种设计模型中，这个系统时定制的，我们并不知道系统每个部分的细节是什么。在每个部分中还有更多的细节。如果我们去深入了解一个这样设计的程序，需要一定是时间。这个我们做项目计划一样，我们已经有一个目标。我需要做的就是：</p><ol><li>把大的目标分散成小目标</li><li>再把小目标分散成更小的目标，直到这个小目标很容易去完成。</li></ol><h3 id="优势" tabindex="-1"><a class="header-anchor" href="#优势" aria-hidden="true">#</a> 优势</h3><ul><li>把问题拆分可以让我们更清楚需要做什么</li><li>每一步的细化，使问题变得更加的简单和容易解决</li><li>模块化的解决方案可以得到复用</li><li>把问题拆分后可以让多人来解决这个问题</li></ul><h2 id="自底向上模型" tabindex="-1"><a class="header-anchor" href="#自底向上模型" aria-hidden="true">#</a> 自底向上模型</h2><p>这个设计中，系统中单独的模块就定义了细节。这个模块链接起来就可以组成一个大的系统。比如我们需要造一辆汽车，我们知道汽车都需要轮胎，方向盘，这些都是汽车的配件，当我们把这些配件组装起来，那我们就认为这个就是一辆车。同时我们也可以时常替换某个组件，比如说轮胎，我们可以把轮胎换成赛车轮胎。</p><h3 id="优势-1" tabindex="-1"><a class="header-anchor" href="#优势-1" aria-hidden="true">#</a> 优势</h3><ul><li>做决策是从低级别来考虑的，这可以最大化复现性</li><li>自定义具有更多灵活性</li></ul><h1 id="区别" tabindex="-1"><a class="header-anchor" href="#区别" aria-hidden="true">#</a> 区别</h1><table><thead><tr><th>自顶向下</th><th>自底向上</th></tr></thead><tbody><tr><td>我们的关注点是把问题拆分的更小</td><td>我们直接解决较小的问题，再把这些解决方案组装起来</td></tr><tr><td>主要使用在结构化编程语言：C、Fortran</td><td>主要使用在面向对象编程语言：C++、C#</td></tr><tr><td>每一个模块都是独立的，所以会有冗余</td><td>冗余最小化通过数据驱动</td></tr><tr><td>模块之间交互很少</td><td>模块之间需要交互数据</td></tr><tr><td>很难被识别</td><td>我们不能构建程序从已经存在的程序中</td></tr><tr><td>细节实现会有一定的难度</td><td>不是我们正常的思维方式</td></tr></tbody></table>',12),h=[i];function l(o,n){return d(),a("div",null,h)}const _=t(r,[["render",l],["__file","Bottom-UpAndTop-Down.html.vue"]]);export{_ as default};
