import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,a as e,b as i,e as n,o as l}from"./app-C7htUUIB.js";const o="/assets/20220125154844-XqkNALTV.png",p="/assets/20220125210247-DgbMVB1Y.png",c="/assets/20220125210734-Bb443DKK.png",h="/assets/20220125211156-DXQsQ55v.png",r={};function d(g,a){return l(),s("div",null,a[0]||(a[0]=[e('<h1 id="physics-based-cloth-simulation" tabindex="-1"><a class="header-anchor" href="#physics-based-cloth-simulation"><span>Physics-Based Cloth Simulation</span></a></h1><h2 id="a-mass-spring-system" tabindex="-1"><a class="header-anchor" href="#a-mass-spring-system"><span>A Mass-Spring System</span></a></h2><h3 id="an-ideal-spring" tabindex="-1"><a class="header-anchor" href="#an-ideal-spring"><span>An Ideal Spring</span></a></h3><h2 id="explicit-integration-of-a-mass-spring-system" tabindex="-1"><a class="header-anchor" href="#explicit-integration-of-a-mass-spring-system"><span>Explicit Integration of A Mass-Spring System</span></a></h2><p>显示积分有一个问题，如果弹性系数过大，弹簧会来回弹跳。</p><h2 id="implicit-integration" tabindex="-1"><a class="header-anchor" href="#implicit-integration"><span>Implicit Integration</span></a></h2><p>弹力是一个 holonomic，只跟位置相关的方程。</p><h2 id="newton-raphson-method" tabindex="-1"><a class="header-anchor" href="#newton-raphson-method"><span>Newton-Raphson Method</span></a></h2><p>解决非线性系统</p><p>限制：函数需要连续</p><p>一阶导数就是在描述一个函数的切方向</p><p>对一个函数的一阶导数做一个泰勒展开:</p>',12),i("p",null,[n("$${F}'(x)\\approx{F}'(x"),i("sup",{"(k)":""},"{(k)}) +{F}''(x"),n(")(x-x^{k})$$")],-1),e('<p>也就是一阶导数可以是在<code>k</code>位置的一阶导数加上<code>k</code>位置的二阶导数乘以<code>Δx</code>。</p><p>方法流程就是：</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>从$x^0$开始计算直到Δx足够小时就中断。</p><p>函数的一阶导数等于0时，既可以是最大值也可以最小值。可以使用二阶导数来判断是最大值还是最小值：</p><ul><li>F&#39;&#39;（x）&gt; 0 ,最小值</li><li>F&#39;&#39;（x）&lt; 0 ,最大值</li><li>如果二阶导数永远大于0，那么函数没有最大值，存在唯一的一个最小值。</li></ul><h2 id="simulation-by-newton-s-method" tabindex="-1"><a class="header-anchor" href="#simulation-by-newton-s-method"><span>Simulation by Newton`s Method</span></a></h2><h2 id="implicit-simulation" tabindex="-1"><a class="header-anchor" href="#implicit-simulation"><span>Implicit Simulation</span></a></h2><p>我们就对每一个顶点模拟，计算它的速度与位置。</p><h3 id="step-1-initial" tabindex="-1"><a class="header-anchor" href="#step-1-initial"><span>Step 1 Initial</span></a></h3><ul><li>初始速度为重力速度：$v_i\\ =(v_i+dt*g)*damping$</li><li>然后计算初步预测每个点的位置：$\\tilde{x_i}=x_i+dt*v_i$</li><li>同步初步预测位置到每个点：$x_i=\\tilde{x_i}$</li></ul><h3 id="step-2-grandient-calculation" tabindex="-1"><a class="header-anchor" href="#step-2-grandient-calculation"><span>Step 2 Grandient Calculation</span></a></h3><p>我们使用隐式积分计算速度与位置是： $$ \\begin{cases} v^{[1]} = v^{[0]}+\\Delta t M^{-1} f^{[1]} \\ x^{[1]} = x^{[0]}+\\Delta tv^{[1]} \\end{cases} $$</p><p>我们可以用速度计算出位置</p>',14),i("p",null,[n("$$ \\begin{cases} x^{[1]} = x^{[0]}+\\Delta tv^{[0]}+ \\Delta t^2 M^{-1} f^{[1]}\\ v^{[1]} = (x"),i("sup",{"[0]":""},"{[1]}-x"),n(")/\\Delta t \\end{cases} $$")],-1),e('<p>然后可以转为以下公式，最后对$x^{[1]}$与$F(x)$求导数，得到到梯度 $\\nabla(F(x^{[1]}))$ 计算方式。 <img src="'+p+'" alt="" loading="lazy"></p><p>对于每一个顶点的梯度就是为：</p><p>$$g_i=\\frac{1}{\\Delta t^2}m_i(x_i-\\tilde{x_i})+f_i$$</p><p>这里的力包含了弹力和重力，弹力可以使用公式得到：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里每个顶点的弹力是相互的，相加为零。同时一个顶点可能会被多个弹簧相连，所以我们需要计算当前顶点的所有弹力相加。</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们就对所有弹簧遍历，对每根弹簧上的顶点计算弹力，然后叠加到梯度上去，我们可以得到公式：</p><p>$$ \\begin{cases} g_i = g_i + k(1-\\frac{L_e}{||X_i-X_j||})(X_i-X_j)\\ g_j = g_j - k(1-\\frac{L_e}{||X_i-X_j||})(X_i-X_j) \\end{cases} $$</p><h3 id="step-3-finishing" tabindex="-1"><a class="header-anchor" href="#step-3-finishing"><span>Step 3 Finishing</span></a></h3><p>我们这里使用简单的方式来代替计算<code>Hessian</code>矩阵，更新位置使用梯度的公式：</p>',11),i("p",null,[n("$$X_i=X_i-(\\frac{1}{\\Delta t"),i("sup",{"-1":""},"2}m_i+4k)"),n("g_i$$")],-1),e('<p>同时再更新速度： $$V = V + \\frac{1}{\\Delta t} (X-\\tilde{X})$$</p><h2 id="bending-and-locking-issues" tabindex="-1"><a class="header-anchor" href="#bending-and-locking-issues"><span>Bending and Locking Issues</span></a></h2><h2 id="a-co-rotational-method" tabindex="-1"><a class="header-anchor" href="#a-co-rotational-method"><span>A CO-Rotational Method</span></a></h2><h2 id="the-locking-issue" tabindex="-1"><a class="header-anchor" href="#the-locking-issue"><span>The Locking Issue</span></a></h2><p>拉伸和弯曲时独立的问题</p><p>弹簧锁死翻折</p><h2 id="position-base-dynamics" tabindex="-1"><a class="header-anchor" href="#position-base-dynamics"><span>Position Base Dynamics</span></a></h2><h2 id="问题" tabindex="-1"><a class="header-anchor" href="#问题"><span>问题</span></a></h2><p>收敛 是什么意思？</p><ul><li>效果，效率</li></ul><p>隐式积分与显示积分的区别？</p>',11)]))}const x=t(r,[["render",d],["__file","cloth.html.vue"]]),f=JSON.parse('{"path":"/Animation/games103/cloth.html","title":"Physics-Based Cloth Simulation","lang":"en-US","frontmatter":{"date":"2022-01-08T16:09:29.000Z","tag":["Animation","Physics"]},"headers":[{"level":2,"title":"A Mass-Spring System","slug":"a-mass-spring-system","link":"#a-mass-spring-system","children":[{"level":3,"title":"An Ideal Spring","slug":"an-ideal-spring","link":"#an-ideal-spring","children":[]}]},{"level":2,"title":"Explicit Integration of A Mass-Spring System","slug":"explicit-integration-of-a-mass-spring-system","link":"#explicit-integration-of-a-mass-spring-system","children":[]},{"level":2,"title":"Implicit Integration","slug":"implicit-integration","link":"#implicit-integration","children":[]},{"level":2,"title":"Newton-Raphson Method","slug":"newton-raphson-method","link":"#newton-raphson-method","children":[]},{"level":2,"title":"Simulation by Newton`s Method","slug":"simulation-by-newton-s-method","link":"#simulation-by-newton-s-method","children":[]},{"level":2,"title":"Implicit Simulation","slug":"implicit-simulation","link":"#implicit-simulation","children":[{"level":3,"title":"Step 1 Initial","slug":"step-1-initial","link":"#step-1-initial","children":[]},{"level":3,"title":"Step 2 Grandient Calculation","slug":"step-2-grandient-calculation","link":"#step-2-grandient-calculation","children":[]},{"level":3,"title":"Step 3 Finishing","slug":"step-3-finishing","link":"#step-3-finishing","children":[]}]},{"level":2,"title":"Bending and Locking Issues","slug":"bending-and-locking-issues","link":"#bending-and-locking-issues","children":[]},{"level":2,"title":"A CO-Rotational Method","slug":"a-co-rotational-method","link":"#a-co-rotational-method","children":[]},{"level":2,"title":"The Locking Issue","slug":"the-locking-issue","link":"#the-locking-issue","children":[]},{"level":2,"title":"Position Base Dynamics","slug":"position-base-dynamics","link":"#position-base-dynamics","children":[]},{"level":2,"title":"问题","slug":"问题","link":"#问题","children":[]}],"git":{"createdTime":1641629369000,"updatedTime":1707212040000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":2},{"name":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2}]},"readingTime":{"minutes":2.49,"words":748},"filePathRelative":"Animation/games103/cloth.md","localizedDate":"January 8, 2022","excerpt":"\\n<h2>A Mass-Spring System</h2>\\n<h3>An Ideal Spring</h3>\\n<h2>Explicit Integration of A Mass-Spring System</h2>\\n<p>显示积分有一个问题，如果弹性系数过大，弹簧会来回弹跳。</p>\\n<h2>Implicit Integration</h2>\\n<p>弹力是一个 holonomic，只跟位置相关的方程。</p>\\n<h2>Newton-Raphson Method</h2>\\n<p>解决非线性系统</p>\\n<p>限制：函数需要连续</p>\\n<p>一阶导数就是在描述一个函数的切方向</p>\\n<p>对一个函数的一阶导数做一个泰勒展开:</p>"}');export{x as comp,f as data};
