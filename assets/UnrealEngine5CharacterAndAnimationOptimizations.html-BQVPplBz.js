import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e,f as n,o as t}from"./app-tSQAYlRo.js";const s="/assets/2025-03-15-13-12-18-DzULb4Tx.png",o="/assets/2025-03-15-13-13-21-64yToOnj.png",r="/assets/2025-03-15-13-14-52-CL_7etjG.png",p="/assets/2025-03-15-13-16-04-BXqRkSco.png",c="/assets/2025-03-15-13-17-17-DOVuQbxC.png",l="/assets/2025-03-15-13-19-04-Bc490a0S.png",g="/assets/2025-03-15-13-31-59-BH3y-Ztz.png",d="/assets/2025-03-15-13-34-00-prQALZ-4.png",f="/assets/2025-03-15-13-36-05-Di_BN8Xt.png",h="/assets/2025-03-15-13-40-51-jHKTaGH8.png",m="/assets/2025-03-15-14-04-27-CDw2vsyK.png",u="/assets/2025-03-15-14-37-51-DqtAl5WR.png",b="/assets/2025-03-15-14-39-28-DgkFGGGg.png",_="/assets/2025-03-15-14-44-27-BtCFB84W.png",x="/assets/2025-03-15-14-47-48-D8FUbDLX.png",y="/assets/2025-03-15-14-52-30-TxDxxz8Z.png",z="/assets/2025-03-15-14-54-44-n3Xuj8Bj.png",S="/assets/2025-03-15-14-58-15-CY5P9sN3.png",D="/assets/2025-03-15-15-05-04-BZVw05VP.png",k="/assets/2025-03-15-15-12-17-qhhy7_he.png",A="/assets/2025-03-15-15-14-54-e84--bGh.png",C="/assets/2025-03-15-15-16-56-DAm0iq-p.png",O="/assets/2025-03-15-15-22-50-DFoJsAxr.png",B="/assets/2025-03-16-15-04-52-D3DRClvU.png",L="/assets/2025-03-16-15-08-31-M6dVk9bn.gif",T="/assets/2025-03-16-15-24-53-CP8O5ssv.png",P="/assets/2025-03-16-15-54-21-DHHDWndX.png",M="/assets/2025-03-16-15-56-28-BJyWDIny.png",U="/assets/2025-03-16-16-00-55-8SeNFc3K.png",v="/assets/2025-03-16-16-16-44-DK6bksg9.png",R="/assets/2025-03-16-16-52-16-C2diOkPe.png",G="/assets/2025-03-16-16-58-45-CN-uGbA5.png",E="/assets/2025-03-16-17-00-30-CAXwhW8i.png",I="/assets/2025-03-16-17-03-49-CtDgBWqP.png",F="/assets/2025-03-16-17-25-09-15QjfSgf.png",N="/assets/2025-03-16-17-29-02-Dmil39Y7.png",w="/assets/2025-03-16-17-31-47-BXDkhRe1.png",j="/assets/2025-03-16-17-33-07-NRPvhYwc.png",W="/assets/2025-03-16-17-43-43-B-piZUUw.png",q="/assets/2025-03-16-17-46-28-CgfFO8VA.gif",V="/assets/2025-03-16-17-52-01-B4CU6THM.png",H="/assets/2025-03-16-17-56-44-DLCRgZmP.gif",J="/assets/2025-03-16-18-00-29-CF1S3YRF.png",K="/assets/2025-03-16-18-09-39-JIh1xxj0.png",X="/assets/2025-03-16-18-12-17-Ct6lBIDA.png",Q="/assets/2025-03-16-18-15-25-uIawyg7o.png",Y="/assets/2025-03-16-18-21-29-QP53pX7_.png",Z="/assets/2025-03-16-18-27-02-D5eCsdWZ.gif",$="/assets/2025-03-16-18-36-05-DbYhbtfR.png",ii="/assets/2025-03-16-18-45-09-D80erH1J.png",ai="/assets/2025-03-16-18-49-54-DoOWygaz.gif",ei="/assets/2025-03-16-18-55-28-ChnPzYtS.png",ni="/assets/2025-03-16-18-57-55-CT5Toh2I.png",ti="/assets/2025-03-16-19-00-04-Cw3Ofo-f.gif",si="/assets/2025-03-16-19-06-15-Cdeb85ZU.gif",oi="/assets/2025-03-16-19-10-02-pEiOOKf9.png",ri="/assets/2025-03-16-19-15-57-DP7ziWJN.png",pi="/assets/2025-03-16-21-14-28-D34OuvBE.png",ci="/assets/2025-03-16-21-17-20-7uI_HjWp.png",li="/assets/2025-03-16-21-19-04-DjCLxNJ5.png",gi="/assets/2025-03-16-21-20-11-BrDo4xRY.png",di="/assets/2025-03-16-21-22-59-DYkAQIEJ.png",fi="/assets/2025-03-16-21-26-46-BEmr_EC5.png",hi="/assets/2025-03-16-21-30-56--73FYEb7.png",mi="/assets/2025-03-16-21-34-48-CW7QmvAv.png",ui="/assets/2025-03-16-21-38-23-iDDB5O4o.png",bi="/assets/2025-03-18-08-08-09-SXpITr5S.png",_i="/assets/2025-03-16-21-41-36-DG_hSXAj.png",xi="/assets/2025-03-16-21-42-57-Due_iQrt.png",yi="/assets/2025-03-16-21-52-50-D8NtJDGx.png",zi="/assets/2025-03-16-21-54-22-D9xHxpl9.png",Si="/assets/2025-03-18-08-10-15-KOU99MUs.png",Di="/assets/2025-03-18-08-12-38-DyQISXl2.png",ki="/assets/2025-03-18-08-13-33-CT_Cq0MG.png",Ai="/assets/2025-03-18-08-14-25-BlillNor.png",Ci="/assets/2025-03-18-08-16-13-A1AZSYTo.png",Oi="/assets/2025-03-18-08-16-55-Bzk7IKds.png",Bi="/assets/2025-03-18-08-17-43-DgAJRSCk.png",Li="/assets/2025-03-18-08-18-49-CJcmtlMs.png",Ti="/assets/2025-03-18-08-22-05-CkZGMvOI.png",Pi="/assets/2025-03-18-08-23-20-DbLP2pK0.png",Mi="/assets/2025-03-18-08-23-55-B13HDRRU.png",Ui="/assets/2025-03-18-08-24-32-CR6nb-rG.png",vi="/assets/2025-03-18-08-33-25-Y2cFVOrf.png",Ri="/assets/2025-03-19-20-42-19-ByKp9tJv.png",Gi="/assets/2025-03-19-20-42-55-xJhbxDLB.png",Ei="/assets/2025-03-19-20-43-41-DpA_R-kg.png",Ii="/assets/2025-03-19-20-47-32--jbnzS9r.png",Fi="/assets/2025-03-19-20-49-24-Bqboi1pT.png",Ni="/assets/2025-03-19-20-53-26-ha0iycTk.png",wi="/assets/2025-03-19-20-56-19-BWObDbhD.png",ji="/assets/2025-03-19-20-59-06-Dd0rlx-X.png",Wi="/assets/2025-03-19-20-59-35-iNBfEzdO.png",qi="/assets/2025-03-19-21-03-51-Cz6nQOPO.png",Vi="/assets/2025-03-19-21-05-22-Cla8bqUx.png",Hi="/assets/2025-03-19-21-06-05-CAOwAaPc.png",Ji="/assets/2025-03-19-21-06-45-BJPRe7ea.png",Ki="/assets/2025-03-19-21-10-10-DCyvKLW6.png",Xi="/assets/2025-03-19-21-11-38-BkJImVyk.png",Qi="/assets/2025-03-19-21-12-08-Bax8qwgq.png",Yi="/assets/2025-03-19-21-16-00-BgyAYYJS.png",Zi="/assets/2025-03-19-21-16-42-C7sQtalM.png",$i="/assets/2025-03-19-21-17-19-D16PCKUK.png",ia="/assets/2025-03-19-21-17-54-i0IXUdT_.png",aa={};function ea(na,i){return t(),e("div",null,i[0]||(i[0]=[n('<h1 id="unreal-engine-5-character-and-animation-optimizations" tabindex="-1"><a class="header-anchor" href="#unreal-engine-5-character-and-animation-optimizations"><span>Unreal Engine 5 Character and Animation Optimizations</span></a></h1><p>这是一篇视频记录，视频地址：<a href="https://www.youtube.com/watch?v=N_suMyUuork" target="_blank" rel="noopener noreferrer">Unreal Engine 5 Character and Animation Optimizations | Unreal Fest 2024</a></p><h2 id="profiling" tabindex="-1"><a class="header-anchor" href="#profiling"><span>Profiling</span></a></h2><h3 id="commands" tabindex="-1"><a class="header-anchor" href="#commands"><span>Commands</span></a></h3><ul><li>Stat FPS <br><img src="'+s+'" alt="" loading="lazy"></li><li>Stat UNIT <br><img src="'+o+'" alt="" loading="lazy"></li><li>Stat UNITGRAPH <br> <img src="'+r+'" alt="" loading="lazy"></li><li>Stat ANIM <br> <img src="'+p+'" alt="" loading="lazy"></li><li>ShowDebug ANIMATION <br> <img src="'+c+'" alt="" loading="lazy"></li></ul><h3 id="size-map" tabindex="-1"><a class="header-anchor" href="#size-map"><span>Size Map</span></a></h3><p>检测当前资源引用到的资源大小，可分别查看内存中的和磁盘中。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="memreport" tabindex="-1"><a class="header-anchor" href="#memreport"><span>MemReport</span></a></h3><p><code>MemReport -full</code> 输出当前内存情况，到<code>Saved/Profiling/MemReports/</code>文件夹中。</p><h3 id="control-rig" tabindex="-1"><a class="header-anchor" href="#control-rig"><span>Control Rig</span></a></h3><p>在Control Rig的类设置中，打开以下选项：</p><figure><img src="'+g+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这样可以实时看到整个Control Rig花的时间：</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以及每个节点的消耗和调用次数：</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="gpu-visualiser" tabindex="-1"><a class="header-anchor" href="#gpu-visualiser"><span>GPU Visualiser</span></a></h3><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="insights" tabindex="-1"><a class="header-anchor" href="#insights"><span>Insights</span></a></h3><ul><li>Channels <ul><li>Animation</li><li>AssetLoadTime</li></ul></li><li>Stat Named Events</li><li>Open Insights After Trace</li></ul><h2 id="animation-sequence" tabindex="-1"><a class="header-anchor" href="#animation-sequence"><span>Animation Sequence</span></a></h2><h3 id="audit" tabindex="-1"><a class="header-anchor" href="#audit"><span>Audit</span></a></h3><h4 id="content-audit-animation-data" tabindex="-1"><a class="header-anchor" href="#content-audit-animation-data"><span>Content Audit Animation Data</span></a></h4><ul><li>Animation Tracks：检查是否有不需要的节点被烘培进动画了，比如把脸部节点也加入到动画中了，但是该动画不需要脸部节点运动。</li><li>Animation Curves：删除不必要的曲线 <br><img src="'+m+'" alt="" loading="lazy"></li></ul><h4 id="animation-track" tabindex="-1"><a class="header-anchor" href="#animation-track"><span>Animation Track</span></a></h4><p>检查动画轨道数量，数量在<strong>66</strong>个左右是非常适合Gameplay的。</p><p>使用<code>Asset Action Utility</code>编写一个简单的方法查询该动画的轨道数量，<a href="https://github.com/BanMing/LyraALS/blob/master/Content/EditorUtilities/EUB_AnimationTrackAudit.uasset" target="_blank" rel="noopener noreferrer">代码源文件</a>，代码如下：</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这样可以右键动画切片时，看到该方法，运行即可：</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>输出如下：</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="animation-import-setting" tabindex="-1"><a class="header-anchor" href="#animation-import-setting"><span>Animation Import Setting</span></a></h4><p>导入动画切片时勾选上以下三个选项：</p><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>设置全部导入配置，在<code>/Engine/Conifg/BaseEditorPerProjectUserSettings.ini</code>文件中的<code>/Script/UnrealEd.FbxAnimSequenceImportData</code>章节配置：</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="audit-example" tabindex="-1"><a class="header-anchor" href="#audit-example"><span>Audit Example</span></a></h4><p>以下原数据：</p><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>减去不必要轨道和曲线后：</p><figure><img src="'+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="anim-graph" tabindex="-1"><a class="header-anchor" href="#anim-graph"><span>Anim Graph</span></a></h3><p>可以在动画蓝图中查看，动画传输的数据，如果除了动画数据还有其他数据在传输，可以看到有其他颜色的线，这样可以用来排查是否有无用数据在传输。</p><figure><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="compression" tabindex="-1"><a class="header-anchor" href="#compression"><span>Compression</span></a></h3><ul><li>Animation Compression Library（ACL） <ul><li>Default &gt;= 5.3</li><li>Unreal Marketplace 4.25 - 5.2</li></ul></li></ul><h2 id="level-of-detail-lod" tabindex="-1"><a class="header-anchor" href="#level-of-detail-lod"><span>Level Of Detail (LOD)</span></a></h2><p>根据距离来减少蒙皮的面数，同时也可以减少骨骼数量、蒙皮权重等。</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在骨骼蒙皮文件中查看LOD的索引：</p><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>创建<code>SkeletalMeshLODSettings</code>配置表设置LOD的细节：</p><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>主要设置以下几个选项：</p><figure><img src="'+O+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="screen-size" tabindex="-1"><a class="header-anchor" href="#screen-size"><span>Screen Size</span></a></h3><p>这是用控制LOD切换的参数，他决定了在屏幕上，模型占据多大比例时切换到特定的LOD级别。<code>ScreenSize</code> 是一个介于0到1之间的浮点值，表示模型在屏幕上的相对大小。</p><ul><li><p>值为1时，表示模型占据整个屏幕高度。</p></li><li><p>值为0.5时，表示模型占据屏幕高度的一半。</p></li><li><p>值为0时，表示模型在屏幕上不可见。</p></li></ul><p>LOD切换逻辑：</p><ul><li><p>当模型的屏幕大小（基于其包围盒）小于或等于 ScreenSize 时，引擎会切换到对应的LOD级别。</p></li><li><p>例如，如果 ScreenSize 设置为0.5，当模型在屏幕上的大小小于或等于屏幕高度的一半时，引擎会使用该LOD级别。</p></li></ul><p>可以使用命令<code>A.VisualizeLODs 1</code> 查看模型在场景中的<code>ScreenSize</code>，如下图：</p><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="lod-hysteresis" tabindex="-1"><a class="header-anchor" href="#lod-hysteresis"><span>LOD Hysteresis</span></a></h3><figure><img src="'+L+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在一些特殊的情况下，LOD会一直切换，即使相机是固定的。为了解决频繁的切换造成的性能和抖动的问题，为LOD切换引入了一个缓冲区域。具体来说逻辑如下：</p><ul><li><p>当模型从高 LOD 切换到低 LOD 时，切换的实际阈值会比配置的 <code>ScreenSize</code> 更低。</p></li><li><p>当模型从低 LOD 切换回高 LOD 时，切换的实际阈值会比配置的 <code>ScreenSize</code> 更高。</p></li></ul><p>假设 <code>ScreenSize</code> 是 LOD 切换的阈值，<code>LODHysteresis</code> 是一个<strong>介于 0 到 1 之间的值</strong>，用于调整切换的缓冲范围。</p><ul><li><p>从高 LOD 切换到低 LOD： 实际切换阈值 = <code>ScreenSize</code> × (1 - <code>LODHysteresis</code>)</p></li><li><p>从低 LOD 切换回高 LOD： 实际切换阈值 = <code>ScreenSize</code> × (1 + <code>LODHysteresis</code>)</p></li></ul><p>例如：</p><p>如果 <code>ScreenSize</code> 为 0.<code>5，LODHysteresis</code> 为 0.1：</p><ul><li><p>从高 LOD 切换到低 LOD 的阈值是 <code>0.5 × (1 - 0.1) = 0.45</code>。</p></li><li><p>从低 LOD 切换回高 LOD 的阈值是 <code>0.5 × (1 + 0.1) = 0.55</code>。</p></li></ul><p>这意味着：</p><ul><li><p>当模型的屏幕大小从大于 0.5 减小到 0.45 时，才会从高 LOD 切换到低 LOD。</p></li><li><p>当模型的屏幕大小从小于 0.5 增加到 0.55 时，才会从低 LOD 切换回高 LOD。</p></li></ul><h3 id="bone-list" tabindex="-1"><a class="header-anchor" href="#bone-list"><span>Bone List</span></a></h3><p>设置骨骼赛选<code>Bone Filer Action Option</code>：</p><ul><li>Remove the joints specified and children</li><li>Only Keep the joints specified and parents</li></ul><p>一个简单的设置例子：</p><ul><li>LOD 01 <ul><li>Remove the joints specified and children <ul><li>Face Joints</li></ul></li></ul></li><li>LOD 02 <ul><li>Only Keep the joints specified and parents <ul><li>Core Skeleton Keep</li></ul></li></ul></li></ul><h3 id="reduction-settings" tabindex="-1"><a class="header-anchor" href="#reduction-settings"><span>Reduction Settings</span></a></h3><figure><img src="'+T+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里有很多设置，核心讲几个比较重要的设置：</p><ul><li><strong>Remap Morph Targets</strong>：<strong>关闭</strong>。<code>Morph Targets</code>是实现模型变形的技术，通过调整顶点的位置来实现面部表情、肌肉、布料等效果。在启用LOD时，引擎会减少模型顶点的数量，那么使用顶点做的变形就需要重新映射顶点。</li><li><strong>Max Bone Influences</strong>：<strong>降低到3和4</strong>。最小的可以降低到0。</li><li><strong>Geometry</strong><ul><li><strong>Enforce Bone Boundaries</strong>： 保留骨骼边界的完整性，避免动画变形问题。</li><li><strong>Merge Coincident Vertices Bones</strong>：合并重合的顶点和骨骼，优化模型数据。</li><li><strong>Volumetric Correction</strong>：保持模型的体积不变，避免形状失真。</li><li><strong>Lock Mesh Edges</strong>：锁定模型边缘，保留硬边和轮廓特征。</li><li><strong>Lock Vertex Colour Boundaries</strong>：保留顶点颜色的完整性，确保颜色信息正确。</li><li><strong>Improve Triangles for Cloth</strong>：优化布料模拟的三角形，提高模拟质量。</li></ul></li></ul><h2 id="animation-blueprint" tabindex="-1"><a class="header-anchor" href="#animation-blueprint"><span>Animation Blueprint</span></a></h2><h3 id="multi-threading" tabindex="-1"><a class="header-anchor" href="#multi-threading"><span>Multi-threading</span></a></h3><p>启用多线程运行动画蓝图。</p><p>确保在<code>Project Settings-&gt;Engine-&gt;General Settings</code>中启用以下选项：</p><figure><img src="'+P+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在每个动画蓝图的中的<code>Class Settings</code>中启用以下选项：</p><figure><img src="'+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container warning"><p class="hint-container-title">Warning</p><p><img src="'+U+'" alt="" loading="lazy"><br><br>在使用<code>Root Motion</code>时，多线处理会失效，因为计算根节点位移实在Game线程中。</p></div><p>将所有更新的逻辑移动到<code>Blueprint Thread Safe Update Aniamtion</code>，并且确保该函数调用的函数是<code>BlueprintThreadSafe</code>启动该选项，获取参数使用<code>Property Access</code>，详情可参考：<a href="https://banming.github.io/GameEngine/Unreal/animation/LyraALS.html#property-access" target="_blank" rel="noopener noreferrer">文章</a></p><h3 id="fast-path" tabindex="-1"><a class="header-anchor" href="#fast-path"><span>Fast Path</span></a></h3><p><code>Fast Path</code>（快速路径） 是动画蓝图（Animation Blueprint）中的一种自动优化机制，旨在提高动画系统的运行效率。它通过减少不必要的计算和逻辑处理，使动画蓝图能够以更高的性能运行。</p><p>启动该机制前提是打开<code>Project Settings-&gt;Engine-&gt;General Settings-&gt;Optimize Anim Blueprint Member Variable Access</code>选项。</p><p>查看节点是否启用了该机制，可以查看蓝图节点上是否有闪电标识如下图：</p><figure><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在动画蓝图中开启<code>Warn About Blueprint Usage</code>选项，可以提示开发者使用的节点是否合理。</p><figure><img src="'+R+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>Fast Path</code> 是引擎自动管理的功能，开发者无法手动启用或禁用它。然而，可以通过以下方式确保动画蓝图能够充分利用 Fast Path：</p><ul><li><p>简化动画蓝图逻辑：</p><ul><li>尽量避免在动画蓝图中使用复杂的逻辑（如自定义事件、复杂的变量计算等）。</li><li>使用简单的节点（如状态机、混合节点、骨骼控制器等）来实现动画逻辑。</li><li>直接调用本地参数，而不是调用引用对象的参数，使用<code>Property Access</code>访问参数。</li></ul></li><li><p>避免使用不支持 <code>Fast Path</code> 的节点：</p><ul><li>某些节点（如蓝图函数调用、自定义事件等）可能会导致 <code>Fast Path</code> 被禁用。</li><li>尽量使用动画系统内置的节点来实现功能。</li><li>不要在<code>AnimGraph</code>中使用<code>And</code>和<code>Or</code>节点<br><img src="'+G+'" alt="" loading="lazy"></li><li>不要在<code>AnimGraph</code>中使用乘法<br><img src="'+E+'" alt="" loading="lazy"></li></ul></li><li><p>优化动画蓝图结构：</p><ul><li>将复杂的逻辑移到 <code>Anim Instance</code> 或 <code>Character Blueprint</code> 中处理，而不是直接在动画蓝图中实现。</li></ul></li></ul><h2 id="animgraph-functions" tabindex="-1"><a class="header-anchor" href="#animgraph-functions"><span>AnimGraph Functions</span></a></h2><p>在<code>AnimGrap</code>中很多计算都不能使用，那应该怎么正确的在<code>AnimGrap</code>中使用计算呢？</p><h3 id="functions-on-nodes" tabindex="-1"><a class="header-anchor" href="#functions-on-nodes"><span>Functions on nodes</span></a></h3><p>使用绑定方法，如下图：</p><figure><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="call-function-node" tabindex="-1"><a class="header-anchor" href="#call-function-node"><span>Call Function Node</span></a></h3><p>在<code>AnimGrap</code>中直接调用方法，使用的是<code>UAnimGraphNode_CallFunction</code>，并且可以设置触发的时机。</p><figure><img src="'+F+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>没有具体使用过该节点，发现只要是在<code>AnimInstance</code>中的方法且开启了<code>BlueprintThreadSafe</code>，都可以在这里选择出来。</p><h3 id="functions-must-be-thread-safe" tabindex="-1"><a class="header-anchor" href="#functions-must-be-thread-safe"><span>Functions Must Be Thread Safe</span></a></h3><p>函数必须打开多线程安全</p><figure><img src="'+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="use-case-fast-path-with-logic-in-animgraph" tabindex="-1"><a class="header-anchor" href="#use-case-fast-path-with-logic-in-animgraph"><span>Use Case - Fast Path With Logic In AnimGraph</span></a></h3><p>以下方式不能触发<code>Fast Path</code>自动优化机制：</p><figure><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以修改为：</p><figure><img src="'+j+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="animgraph-lods" tabindex="-1"><a class="header-anchor" href="#animgraph-lods"><span>AnimGraph LODs</span></a></h2><h3 id="node-lods" tabindex="-1"><a class="header-anchor" href="#node-lods"><span>Node LODs</span></a></h3><p>可以设置节点上LOD来控制节点是否运行：</p><figure><img src="'+W+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>比如下图的叠加动画，当前角色LOD值大于填的值，就不会执行该节点</p><figure><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="predicted-lod-level" tabindex="-1"><a class="header-anchor" href="#predicted-lod-level"><span>Predicted LOD Level</span></a></h3><figure><img src="'+V+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用预测LOD来控制动画播放，比如下图：</p><figure><img src="'+H+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="post-process-abp-lod" tabindex="-1"><a class="header-anchor" href="#post-process-abp-lod"><span>Post Process ABP LOD</span></a></h3><p>在骨骼蒙皮文件中可以对动画后处理蓝图进行设置LOD</p><figure><img src="'+J+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="animgraph-practices" tabindex="-1"><a class="header-anchor" href="#animgraph-practices"><span>AnimGraph Practices</span></a></h2><h3 id="space-conversion-bundles" tabindex="-1"><a class="header-anchor" href="#space-conversion-bundles"><span>Space Conversion Bundles</span></a></h3><p>尽量减少使用空间转化的节点，把需要同一个空间计算的节点放在一起。</p><figure><img src="'+K+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="state-machine-settings" tabindex="-1"><a class="header-anchor" href="#state-machine-settings"><span>State Machine Settings</span></a></h3><figure><img src="'+X+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>Max Transitions Per Frame</code> 和 <code>Max Transitions Requests</code>可以适当的减少。</p><h3 id="cached-pose" tabindex="-1"><a class="header-anchor" href="#cached-pose"><span>Cached Pose</span></a></h3><p>多使用缓存姿势：</p><figure><img src="'+Q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>不要在状态机里再套状态机，可以把所有状态机放在最上层，然后把他们的姿势存起来再使用。</p><h2 id="skeleton-pose-update" tabindex="-1"><a class="header-anchor" href="#skeleton-pose-update"><span>Skeleton Pose Update</span></a></h2><h3 id="visibility-base-anim-tick" tabindex="-1"><a class="header-anchor" href="#visibility-base-anim-tick"><span>Visibility Base Anim Tick</span></a></h3><p>在<code>SkeletonMeshComponent-&gt;Details-&gt;Optimization</code>中设置:</p><figure><img src="'+Y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以设置为<code>Only Tick Pose when Rendered</code>，表现如下图：</p><figure><img src="'+Z+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>统一修改<code>Project/Config/DefaultEngine.ini</code>文件中：</p><div class="language-ini line-numbers-mode" data-highlighter="prismjs" data-ext="ini"><pre><code><span class="line"><span class="token section"><span class="token punctuation">[</span><span class="token section-name selector">/Script/Engine.SkeletalMeshComponent</span><span class="token punctuation">]</span></span></span>
<span class="line"><span class="token key attr-name">VisibilityBaseAnimTickOption</span><span class="token punctuation">=</span><span class="token value attr-value">OnlyTickPoseWhenRendered</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div></div></div><p>这只能修改到<code>SkeletalMeshComponent</code>，并不能修改<code>Skeletal Mesh Actors</code>。如果想要全部修改的话，只有修改引擎文件：</p><ul><li><code>SkinnedMeshComponent.cpp</code>构造函数中<code>VisibilityBasedAnimTickOption</code>的默认值</li><li><code>SkeletalMeshActor.cpp</code>构造函数中<code>SkeletalMeshComponent-&gt;VisibilityBasedAnimTickOption</code>的默认值</li></ul><h3 id="no-skeleton-update" tabindex="-1"><a class="header-anchor" href="#no-skeleton-update"><span>No Skeleton Update</span></a></h3><p>在一些场景中人物不需要更新骨骼，可以启用<code>USkeletalMeshComponent-&gt;bNoSkeletonUpdate</code>选项，停止更新骨骼，同时动画和物理模拟也不会更新了。</p><figure><img src="`+$+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以使用一个触发盒来启用该选项，离开该盒子后就关闭该选项。</p><h3 id="update-rate-optimizations" tabindex="-1"><a class="header-anchor" href="#update-rate-optimizations"><span>Update Rate Optimizations</span></a></h3><p>打开以下两个选项：</p><figure><img src="'+ii+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看到更新的频率：</p><p><img src="'+ai+'" alt="" loading="lazy"><br> 不同颜色的表示：</p><ul><li><p>绿色：</p><ul><li>表示骨骼网格体正在以 <strong>最高频率</strong> 更新（例如每帧更新）。</li><li>这意味着该骨骼网格体没有被优化，或者优化被禁用。</li></ul></li><li><p>黄色：</p><ul><li>表示骨骼网格体正在以 <strong>较低的频率</strong> 更新（例如每两帧更新一次）。</li><li>这是 <code>URO</code> 的典型优化状态，表示骨骼网格体的更新频率被降低以节省性能。</li></ul></li><li><p>红色：</p><ul><li>表示骨骼网格体 <strong>完全停止更新</strong>。</li><li>这意味着骨骼网格体的更新被跳过，通常是因为它被认为对当前帧的渲染不重要。</li></ul></li><li><p>蓝色：</p><ul><li>表示骨骼网格体正在以 <strong>最低频率</strong> 更新（例如每四帧更新一次）。</li><li>这是更激进的优化状态，适用于对性能要求极高的场景。</li></ul></li></ul><p>如果你不想使用C++来编写更新频率的逻辑，可以使用下面这个<a href="https://www.unrealengine.com/marketplace/en-US/product/update-rate-optimisation-blueprint-nodes" target="_blank" rel="noopener noreferrer">插件</a>：</p><figure><img src="'+ei+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以下是简单的一个示例根据LOD数值控制刷新率：</p><figure><img src="'+ni+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>下面是一个简单控制刷新率的例子，没有进行插值的效果如下：</p><figure><img src="'+ti+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在打开插值过后，可以看到20帧刷新一次的跟每帧刷新一次的没有太大的区别：</p><figure><img src="'+si+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="budgeted-skeletal-mesh-component" tabindex="-1"><a class="header-anchor" href="#budgeted-skeletal-mesh-component"><span>Budgeted Skeletal Mesh Component</span></a></h3><p>插件<code>Animation Budget Allocator</code></p><figure><img src="'+oi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用<code>Skeletal Mesh Component Budgeted</code>替换所有的<code>Skeletal Mesh Component</code></p><figure><img src="'+ri+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后再使用命令<code>a.Budget.Enabled 1</code>启用</p><figure><img src="'+pi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这样就可以看到当前场景中的<code>Skeletal Mesh Component Budgeted</code>使用情况：</p><figure><img src="'+ci+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以手动设置动画的预算为1ms：</p><figure><img src="'+li+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>查看场景中的表现：</p><figure><img src="'+gi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="texture" tabindex="-1"><a class="header-anchor" href="#texture"><span>Texture</span></a></h2><h3 id="texture-size" tabindex="-1"><a class="header-anchor" href="#texture-size"><span>Texture Size</span></a></h3><p>图片的倍数：</p><figure><img src="'+di+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="size-limit" tabindex="-1"><a class="header-anchor" href="#size-limit"><span>Size Limit</span></a></h3><p>可以设置贴图中的<code>Maximum Texture Size</code>来控制纹理最大分辨率，它决定了纹理在导入或运行时可以被压缩到的最大尺寸。</p><figure><img src="'+fi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以下是一个4k图片设置对比：</p><figure><img src="'+hi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>统一修改在文件<code>Engine\\Config\\BaseDeviceProfiles.ini - GlobalDefaults DeviceProfile</code>：</p><figure><img src="'+mi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>设置<code>Texture Group</code>在<code>Texture -&gt; Level of Detail -&gt; Texture Group Character</code> :</p><figure><img src="'+ui+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以多选贴图使用<code>Property Matrices</code>同时设置。</p><h3 id="micro-detail" tabindex="-1"><a class="header-anchor" href="#micro-detail"><span>Micro Detail</span></a></h3><p>细节纹理容易在压缩纹理之后丢失掉，看起来会很糊。</p><figure><img src="'+bi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>所以我们可以将这些细节纹理用Shader的方式呈现，比如在材质中Tiling这些细节纹理，而不是将细节纹理烘焙在主纹理上。</p><figure><img src="'+_i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="compression-1" tabindex="-1"><a class="header-anchor" href="#compression-1"><span>Compression</span></a></h3><h4 id="the-cost-of-aphla" tabindex="-1"><a class="header-anchor" href="#the-cost-of-aphla"><span>The Cost of aphla</span></a></h4><p>一般导入是以下格式，不过需要手动检查以下该图片是否需要透明通道，如果不需要就需要启用以下这个选项：</p><figure><img src="'+xi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以下是有透明通道和没有透明通道的对比：</p><figure><img src="'+yi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>压缩算法的编码不同导致储存大小不同，对比如下图。如果我们的磁盘与内存真的不够，就需要重点考虑哪些纹理确实不需要Alpha通道，哪些纹理不需要高精度的颜色表现了。</p><figure><img src="'+zi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="g8" tabindex="-1"><a class="header-anchor" href="#g8"><span>G8</span></a></h4><p>有时候我们只需要单通道纹理，这时候G8压缩方法就比较好，这个方法会只留下Red通道。所有这些压缩方法可以在纹理的细节面板中调整。</p><figure><img src="'+Si+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="oodle" tabindex="-1"><a class="header-anchor" href="#oodle"><span>Oodle</span></a></h3><p>我们在打开纹理编辑器的时候可能就已经见过这个藏在角落的Oodle面板了，但这个东西到底有什么用？</p><figure><img src="'+Di+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个面板可以让我们调整相关的纹理编码参数：</p><figure><img src="'+ki+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当我们调整出了一个看起来很满意的参数之后就可以在<code>BaseEngine</code>配置文件中修改全局默认值了。</p><figure><img src="'+Ai+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="channel-packing" tabindex="-1"><a class="header-anchor" href="#channel-packing"><span>Channel Packing</span></a></h3><p>通道合成 一个很常见的例子就是将<code>AO</code>遮罩、粗糙度遮罩和金属度遮罩合并成一张<code>RGB</code>纹理。我们甚至还可以加多一张<code>Emissive</code>或者别的什么遮罩放在<code>Alpha</code>通道里，随我们喜欢。这样我们就可以在材质中减少纹理采样，优化纹理复杂度。  <br><img src="'+Ci+'" alt="" loading="lazy"></p><p>在权衡了纹理质量的前提下，想要追求极致优化，可以合成法线纹理。首先我们需要将法线纹理的压缩设置改回默认，然后在材质中这么写。这样我们就可以往法线纹理的B通道中加东西了。</p><figure><img src="'+Oi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>注意！这种方案非常影响纹理的质量，下图是结果，请权衡好质量与优化。</p><figure><img src="'+Bi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="masks-rgb" tabindex="-1"><a class="header-anchor" href="#masks-rgb"><span>Masks RGB</span></a></h3><p>蒙版-大部分人会以为只能往RGBA纹理中塞4种蒙版，但其实我们可以往里面塞9种蒙版！</p><figure><img src="'+Li+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="skeletal-mesh-components" tabindex="-1"><a class="header-anchor" href="#skeletal-mesh-components"><span>Skeletal Mesh Components</span></a></h2><h3 id="bounds" tabindex="-1"><a class="header-anchor" href="#bounds"><span>Bounds</span></a></h3><p>骨骼网格体组件还有更多参数设置。我们在更新骨骼网格体时会更新它的包围盒，包围盒的更新我们也可以进行一些调整。执行<code>ShowFlag.Bounds 1</code>可以显示组件的包围盒，这个可以帮助我们Debug。</p><figure><img src="'+Ti+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>一般可以设置以下几个：</p><ul><li><p>上文提到过，骨骼网格体可以跳过更新帧，然后通过插值对骨骼变形进行平滑。而包围盒的更新也可以跳过更新帧，并且不在平滑后更新。将包围盒更新模式调整成<code>Skip Bounds Update When Interpolating</code>即可。</p></li><li><p>因为遮蔽剔除和相机剔除都是用包围盒计算的，假如包围盒进入剔除范围，这个组件就不会被渲染。骨骼网格体组件可以固定包围盒（<code>Component Use Fixed Skel Bounds</code>），但存在一定的风险，它可能会在应该渲染的时候不渲染。当然，如果确定我们的角色不会超过这个包围盒，我们就可以放心使用固定包围盒。<br><img src="'+Pi+'" alt="" loading="lazy"></p></li><li><p>如果我们采用了模块化角色方案，可以调整成使用父项骨骼网格体的包围盒模式（<code>Use Parent Bounds/Bounds From Leader Pose Component</code>）。<br> <img src="'+Mi+'" alt="" loading="lazy"></p></li></ul><p>以上这些设置能在<code>USkeletalMeshComponent</code>找到：</p><figure><img src="'+Ui+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="render-static" tabindex="-1"><a class="header-anchor" href="#render-static"><span>Render Static</span></a></h3><p>假如我们有一个骨骼网格体，但是它在游戏内不需要动画，这时候这个<code>Render Static</code>选项就很有用。并且这个选项可以在游戏内自由调节。</p><figure><img src="'+vi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="nanite-skeleton" tabindex="-1"><a class="header-anchor" href="#nanite-skeleton"><span>Nanite Skeleton</span></a></h3><p>现在Nanite骨骼网格体还没出，但我们可以用点小伎俩。比如我们可以导入一个只有单个三角面的骨架（因为虚幻不允许导入没有面与蒙皮的骨骼网格体），然后将这个三角面关掉。</p><figure><img src="'+Ri+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>导入一些静态网格体，静态网格体可以用Nanite，然后再将他们绑定在骨架上。</p><figure><img src="'+Gi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这样我们就得到了一个“Nanite骨骼网格体”，这非常适用于各种刚性的骨骼网格体上。</p><figure><img src="'+Ei+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="blueprints" tabindex="-1"><a class="header-anchor" href="#blueprints"><span>Blueprints</span></a></h2><h3 id="tick" tabindex="-1"><a class="header-anchor" href="#tick"><span>Tick</span></a></h3><h4 id="option" tabindex="-1"><a class="header-anchor" href="#option"><span>Option</span></a></h4><ul><li><p>Turn it Off by Default</p><ul><li>Blueprint <br><img src="'+Ii+'" alt="" loading="lazy"></li><li>Component <br> <img src="'+Fi+'" alt="" loading="lazy"></li></ul></li><li><p>Turn it Off by Default - Source Code</p><ul><li>Actor.cpp - PrimaryActorTick.bStartWithTickEnabled = false;</li><li>ActorComponent.cpp - PrimaryComponentTick.bStartWithTickEnabled = false;</li><li>Controller.cpp - PrimaryActorTick.bStartWithTickEnabled = true;</li></ul></li></ul><h4 id="tick-rate" tabindex="-1"><a class="header-anchor" href="#tick-rate"><span>Tick Rate</span></a></h4><figure><img src="'+Ni+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>Source Code：</p><ul><li>Actor.cpp - PrimaryActorTick.TickInterval = 1.0f;</li><li>ActorComponent.cpp - PrimaryComponentTick.TickInterval = 1.0f;</li></ul><h4 id="dumpticks" tabindex="-1"><a class="header-anchor" href="#dumpticks"><span>dumpTicks</span></a></h4><p>执行dumpTicks指令可以输出现在在Tick的事件有哪些。</p><figure><img src="'+wi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="references" tabindex="-1"><a class="header-anchor" href="#references"><span>References</span></a></h3><p>引用如果处理不当也会出现大问题，这会导致资产拖着一堆引用，导致加载不畅或者内存占用高。当我们打开<code>Size Map</code>就能看到资产的硬引用，加载第三人称角色蓝图意味着要加载上<code>Size Map</code>上显示的这些资产。</p><figure><img src="'+ji+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>举一个反面案例，这是硬引用处理不当导致的。加载角色的时候加载多了一些载具相关的东西。</p><figure><img src="'+Wi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><strong>这是因为角色蓝图里有一个载具类引用的变量，或者<code>Cast To</code>了载具类。</strong></p><figure><img src="'+qi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="interface" tabindex="-1"><a class="header-anchor" href="#interface"><span>Interface</span></a></h4><p>如何处理<code>Cast</code>就很重要了，首先如果我们确实需要用到某个类，放心<code>Cast</code>，比如角色与动画蓝图之间的<code>Cast</code>。</p><figure><img src="'+Vi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>但如果我们真的需要用到类里面的逻辑怎么办？可以试试用接口。</p><figure><img src="'+Hi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后在蓝图中实现它即可。</p><figure><img src="'+Ji+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="soft-reference" tabindex="-1"><a class="header-anchor" href="#soft-reference"><span>Soft Reference</span></a></h4><figure><img src="'+Ki+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>软引用能做的东西不多，并且我们在使用它之前得将它加载成硬引用。Blocking节点会阻塞游戏线程，而Async节点会异步完成加载任务。</p><figure><img src="'+Xi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><div class="hint-container warning"><p class="hint-container-title">Warning</p><p>要注意的是，以上这些节点加载出来的引用会卡在蓝图的生命周期里，不会被垃圾收集处理，在加载完，完成了对应的任务之后，推荐用一个<code>Set Object Reference (by ref)</code>节点清掉这个引用，让垃圾收集处理它。<br><img src="'+Qi+'" alt="" loading="lazy"></p></div><h3 id="parent-class-component-assignments" tabindex="-1"><a class="header-anchor" href="#parent-class-component-assignments"><span>Parent Class Component Assignments</span></a></h3><p>我们一般会将角色蓝图的子蓝图作为角色的变体，修改里面的网格体和里面的一些参数。这个例子是用<code>Quinn</code>的主蓝图生成了一个<code>Mannequin</code>的子蓝图。</p><figure><img src="'+Yi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>当我们打开子蓝图的<code>Size Map</code>就会发现，它加载上了主蓝图中的<code>Quinn</code>骨骼网格体。</p><figure><img src="'+Zi+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这种情况下，需要将主蓝图中的网格体或者其他一些硬引用去掉。</p><figure><img src="'+$i+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>然后再创建两个子蓝图，分别对应Quinn和Mannequin。这样两个子蓝图就会只加载自己对应的引用资产。</p><figure><img src="'+ia+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><ul><li><a href="https://mp.weixin.qq.com/s/h3owu_iscj0nSVHaxnXIzA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/h3owu_iscj0nSVHaxnXIzA</a></li></ul>',289)]))}const oa=a(aa,[["render",ea],["__file","UnrealEngine5CharacterAndAnimationOptimizations.html.vue"]]),ra=JSON.parse('{"path":"/GameEngine/Unreal/animation/UnrealEngine5CharacterAndAnimationOptimizations.html","title":"Unreal Engine 5 Character and Animation Optimizations","lang":"en-US","frontmatter":{"date":"2025-03-16T18:57:03.000Z","tag":["Unreal Engine","Animation"]},"git":{"createdTime":1742258231000,"updatedTime":1742390596000,"contributors":[{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":2,"url":"https://github.com/BanMing"}]},"readingTime":{"minutes":17.5,"words":5249},"filePathRelative":"GameEngine/Unreal/animation/UnrealEngine5CharacterAndAnimationOptimizations.md","localizedDate":"March 16, 2025","excerpt":"\\n<p>这是一篇视频记录，视频地址：<a href=\\"https://www.youtube.com/watch?v=N_suMyUuork\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">Unreal Engine 5 Character and Animation Optimizations | Unreal Fest 2024</a></p>\\n<h2>Profiling</h2>\\n<h3>Commands</h3>\\n<ul>\\n<li>Stat FPS <br></li>\\n<li>Stat UNIT <br></li>\\n<li>Stat UNITGRAPH <br> </li>\\n<li>Stat ANIM <br> </li>\\n<li>ShowDebug ANIMATION <br> </li>\\n</ul>"}');export{oa as comp,ra as data};
