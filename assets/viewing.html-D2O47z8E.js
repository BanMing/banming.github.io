import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{r as a,c as r,e,d as n,f as o,w as p,a as s,o as c}from"./app-BiyDVjIV.js";const l={},g=s('<h1 id="转换" tabindex="-1"><a class="header-anchor" href="#转换"><span>转换</span></a></h1><p>转换是一个三维场景中的物体变化到屏幕二维空间上的一个过程，这个过程大致如下：</p><figure><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/20201202203902.png" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们常说的<strong>MVP矩阵</strong>转换。</p><ul><li><strong>M</strong>odeling : 模型变换</li><li><strong>V</strong>iew : 视图/相机变换，也就是图中的Camera transformation</li><li><strong>P</strong>rojection : 投影变换</li></ul><p>这里在加上一个视口变换，就完成了所有转化。</p><h2 id="视图-相机变换" tabindex="-1"><a class="header-anchor" href="#视图-相机变换"><span>视图/相机变换</span></a></h2><p>这里我们先说视图变换，这样会好理解一些。</p><h3 id="定义相机" tabindex="-1"><a class="header-anchor" href="#定义相机"><span>定义相机</span></a></h3><p>首先我们要知道怎么去定义一个相机，我们要想知道它在场景中的信息，可以通过以下几个向量来知道:</p><ul><li>相机的位置坐标 <strong>e</strong></li><li>相机的照射方向 <strong>g</strong></li><li>相机的向上方向 <strong>t</strong></li></ul><p>相机定义图：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/camera_dinfine.png" width="30%"><p>我们经常为了方便，在拍照的时候，先把相机固定了，构好图，然后再调整姿势。在渲染图片的时候我们也为方便也先固定好相机，所以约定相机：</p><ul><li>我们需要把相机移动到世界坐标原点，</li><li>看向的方向为负z轴方向</li><li>向上方向与y轴正方向一样。</li></ul><p>那我们要把相机设置成上面的状态。这个过程我们也可以认为是把相机从自己的坐标系转移到世界坐标系中，因为相机在世界坐标系原点。</p><hr><h3 id="转换过程" tabindex="-1"><a class="header-anchor" href="#转换过程"><span>转换过程</span></a></h3><p>我们就可以先把相机移动到原点，然后再把相机旋转到指定的方向。这样会方便计算旋转。 我们可以得到公式：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/rt.png" width="30%"><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>因为使用矩阵(<strong>M</strong>view)最后乘以相机坐标,所以这里是需要反过来相乘。</p></div><h4 id="平移" tabindex="-1"><a class="header-anchor" href="#平移"><span>平移</span></a></h4><p>只需把相机坐标<strong>e</strong>移动到原点即可得到平移矩阵（视角变换）：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/translate_martix.svg" width="40%"><br><h4 id="旋转" tabindex="-1"><a class="header-anchor" href="#旋转"><span>旋转</span></a></h4><p>我们要旋转任意的角度，可以分别沿想x、y、z轴旋转即可。获得旋转：</p><ul><li><strong>t</strong> x <strong>g</strong> 旋转到x轴正方向</li><li><strong>t</strong> 旋转到y轴正方向</li><li><strong>g</strong> 旋转到z轴负方向</li></ul><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>我们这里定义一下 <strong>t</strong> x <strong>g</strong> 这个方向为 <strong>r</strong> 方便用</p></div><p>这样子我们并不是很好的去求解旋转矩阵，我们可以反向旋转。先求到结果点旋转到原始点的旋转矩阵，即世界坐标轴旋转到相机在世界坐标的方向，然后对矩阵求逆即可。</p><ul><li>旋转 <strong>x</strong> 轴正方向 <strong>r</strong> (1,0,0) 到 (rx,ry,rz)</li><li>旋转 <strong>y</strong> 轴正方向 <strong>t</strong> (0,1,0) 到 (tx,ty,tz)</li><li>旋转 <strong>z</strong> 轴正方向 <strong>-g</strong> (0,0,1) 到 (-gx,-gy,-gz)</li></ul><p>从原点旋转得到相机场景中的矩阵：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/rotate_inverse_martix.svg" width="40%">',33),d=s('<p>所以我们的旋转矩阵为： <img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/rotate_matrix.svg" width="40%"></p><hr><h2 id="模型变换" tabindex="-1"><a class="header-anchor" href="#模型变换"><span>模型变换</span></a></h2><p>我们把相机移动到世界坐标原点位置并且方向都改变了，物体被相机渲染出来的位置都不正确了吧。这里我们就要用到初中物理 <strong>相对运动</strong>。我们在移动相机的同时也移动物体，这样就可以保持相对运动，这样一来就可以使相机渲染出来的结果不变。这个过程我们常常叫<strong>模型变换（modeling transformation）</strong>。所以我们也把场景中的所有物体模型的位置坐标乘上上面我们求到 <strong>Tview</strong> 矩阵。</p><hr><h2 id="投影变换" tabindex="-1"><a class="header-anchor" href="#投影变换"><span>投影变换</span></a></h2><p>我们把相机和物体都摆放好了，我们就需要开始把场景中的物体映射到一个图片上了。这个过程叫做<strong>相机投影</strong>，这里我们把投影分为两种：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-23-17_16_35.png" width="80%"><ul><li>透视投影（Projective Projection）：把相机看做一个点形成一个锥体。</li><li>正交投影（Orthographic Projection）：把相机放的无限远后，投影出近处物体与远处的物体的大小差不多相同。</li></ul><h3 id="正交投影" tabindex="-1"><a class="header-anchor" href="#正交投影"><span>正交投影</span></a></h3><p>我们可以想象把物体坐标的z值去掉，然后平行投影到 [-1,1]² 的一个矩形中。投影到屏幕坐标范围 [0,1](NDC Normalized Device Coordinates)</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-23-17_18_59.png" width="80%"><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>这里的 [-1,1]² 矩形是约定俗成。</p></div><p>有点像俯视图（平面图）的感觉。我们先把物体移动到世界坐标原点，然后对其进行缩放。我们具体怎么去实现这个过程呢？如下图：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-23-17_40_38.png"><p>我们先把物体移动到坐标原点，然后把物体缩放到一个 [-1,1]³ 的一个立方体中。这个立方体叫做“规范立方体”（canonical cube）。这其中参数：</p><ul><li>l 盒子最左边 （x轴）left</li><li>r 盒子最右边 （x轴）right</li><li>t 盒子最上边 （y轴）top</li><li>b 盒子最下边 （y轴）bottom</li><li>n 盒子最前边 （z轴）near</li><li>f 盒子最远边 （z轴）far</li></ul><p>这样我们就可以写出变换矩阵了：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-23-17_45_38.png" width="80%"><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>这里n与f都是在z轴上的，相机的朝向是z轴负方向所以这里n的值是比f大。</p><p>因为我们的立方体是 [-1,1] 长宽高都为2，所以我们的缩放是2除以原来物体的长度。</p></div><p>最终矩阵： <img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-23-17_50_04.png" width="60%"></p><h3 id="透视投影" tabindex="-1"><a class="header-anchor" href="#透视投影"><span>透视投影</span></a></h3><p>正常我们人眼看到的构图结构———远小近大，就是透视投影。 透视投影我们需要三维的场景映射到观察窗口，然后把映射到窗口的做一次正交投影。 前面了解到，透视投影是把相机作为一个点，这样我们可以来获得一个横截面：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-26-11_54_39.png" width="80%"><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>观察窗口可以简单的理解为屏幕</p></div><p>各个参数：</p><ul><li><strong>e</strong>为相机位置</li><li><strong>g</strong>为相机照射方向</li><li><strong>n</strong>为相机到屏幕距离</li><li><strong>y</strong>场景中一点的高度基于<strong>g</strong></li><li><strong>ys</strong>我们需要求得屏幕映射点的高度基于<strong>g</strong></li></ul><p>这里最重要的根据就是相似三角形，可以得到公式: <img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-26-12-04.svg" width="13%"></p><p>同时我们也可以得到： <img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-26-12-11.svg" width="13%"></p><p>我们可以先写出一个简单的关系：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-27-15-01.svg" width="80%"><div class="hint-container tip"><p class="hint-container-title">Tips</p><p>这里用到一个齐次坐标的特性：</p><ul><li>(x,y,z,1)</li><li>(kx,ky,kz,k)</li><li>(zx,zy,z*z,z)</li></ul><p>以上三个都代表点(x,y,z),当然这里乘上的系数不能为0。如k和z都不能为0。</p></div><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/20201202231251.png" width="60%"><p>这里我们的Zs一直不知道是什么，所以在乘上Z后还是不知道。这里我们已经获得一个矩阵的部分，我们只需要求出第三行即可。这个里我们用特殊值得方法来求:</p><div class="hint-container tip"><p class="hint-container-title">Tips</p><ul><li><strong>n</strong> 相机的照射到的近平面的z值，相机到屏幕</li><li><strong>f</strong> 相机的照射到的远平面的z值</li></ul></div><ul><li><p>当我们设的点就是屏幕上的点，这里我们的<strong>Zs</strong>和<strong>Z</strong>都为<strong>n</strong>，公式：<strong>Zs</strong> = <strong>Z</strong> = <strong>n</strong>。这里就可以写出以下等式：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-27-16_07_394.png" width="100%"><p>这里的小步骤：</p><ul><li>先把 <strong>[x,y,z,1]Τ</strong> 中间的 <strong>Z</strong> 替换成 <strong>n</strong> 得到 <strong>[x,y,n,1]Τ</strong></li><li>然后把每一位都乘以 <strong>n</strong> 得到 <strong>[nx,ny,n²,n]Τ</strong></li><li>这个形式很像上面矩阵计算的第三个 <strong>[nx,ny,*,z]Τ</strong>，把这其中的 <strong>z</strong> 也换成 <strong>n</strong>，得到 <strong>[nx,ny,*,n]Τ</strong>，所以说这里的*就为<strong>n²</strong>。</li></ul><p>这里因为等于 <strong>n²</strong> 所以跟 <strong>x</strong> 与 <strong>y</strong> 都没有关系的，所以我们就可以写出上面最后一个相乘矩阵第三行的计算等式：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-27-16_10_44.png" width="40%"><p>然后我们可以写出一个等式：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-27-16_24_02.png" width="80%"></li><li><p>当我们设的点为远平面，在越来越远的地方它的 <strong>Zs</strong> 和 <strong>Z</strong> 都为 <strong>f</strong> ，公式：<strong>Zs</strong> = <strong>Z</strong> = <strong>f</strong> 。同理也可以得到下面的等式：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-27-16_28_10.png" width="70%"></li></ul><p>这两个等式解出来A与B如下：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-27-16_31_30.png" width="70%"><p>最终写出透视投影到正交投影的矩阵：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-27-16_33_28.png" width="70%"><p>这里最后再乘上正交投影即可:</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/2020-10-27-16_53_29.png" width="70%"><h3 id="视锥" tabindex="-1"><a class="header-anchor" href="#视锥"><span>视锥</span></a></h3><p>我们相机是透视照射的话，就可以调整一个参数叫<strong>fov</strong>也就是视锥。我们可以用 <strong>(l, r, b, t)</strong> 来定义任意一个窗口， <strong>n</strong> 作为相机到窗口的距离。</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/fov.png" width="%"><p>这其中的关系有：</p><ul><li><strong>l</strong> = <strong>-r</strong></li><li><strong>b</strong> = <strong>-t</strong></li><li>宽高比 <strong>aspect</strong> = <strong>r</strong> / <strong>t</strong></li><li>这里的Θ也就是我们的fovY可以得到<img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/20201202234024.png" width="30%"></li></ul><h2 id="视口变换" tabindex="-1"><a class="header-anchor" href="#视口变换"><span>视口变换</span></a></h2><p>把之前算好的标准立方体的x和y拉伸到屏幕分辨率大小叫做视口变换。</p><ul><li>Z值不变</li><li>width:屏幕宽度 height:屏幕高度</li><li>xy平面 [-1,1]² 转换到 [0,width] x [0,height]</li></ul><p>这样就可以得到转换矩阵：</p><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/20201202210121.png" width="%"><h2 id="最终结果" tabindex="-1"><a class="header-anchor" href="#最终结果"><span>最终结果</span></a></h2><br><img src="https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/MommyTalk1606956109764.svg" width="100%">',55),h=s(`<p>我们可以得到简单伪代码：</p><div class="language-cpp line-numbers-mode" data-ext="cpp" data-title="cpp"><pre class="language-cpp"><code>function  <span class="token function">view_transform</span><span class="token punctuation">(</span>projection<span class="token punctuation">,</span>view<span class="token punctuation">,</span>model<span class="token punctuation">)</span>
  <span class="token comment">// mvp transformation</span>
  mvp <span class="token operator">=</span> projection <span class="token operator">*</span> view <span class="token operator">*</span> model
  <span class="token keyword">for</span> vertex in allVertexes <span class="token keyword">do</span> 
    vertex <span class="token operator">=</span> mvp <span class="token operator">*</span> vertex
  
  <span class="token comment">//Homogeneous division</span>
  <span class="token keyword">for</span> vertex in allVertexes <span class="token keyword">do</span> 
    vertex <span class="token operator">/=</span> vertex<span class="token punctuation">.</span>w

  <span class="token comment">//Viewport transformation</span>
  <span class="token keyword">for</span> vertex in allVertexes <span class="token keyword">do</span> 
    vertex<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> width <span class="token operator">*</span> <span class="token punctuation">(</span>vertex<span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">)</span>
    vertex<span class="token punctuation">.</span>y <span class="token operator">=</span> <span class="token number">0.5</span> <span class="token operator">*</span> height <span class="token operator">*</span> <span class="token punctuation">(</span>vertex<span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token number">1.0</span><span class="token punctuation">)</span>
    <span class="token comment">// vertex.z = -vertex.z * f1 +f2</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这里的视口变换是直接写的结果试子，我们也可以直接传入矩阵</p>`,3);function m(u,v){const i=a("RouteLink");return c(),r("div",null,[g,e("p",null,[n("我们可以很清晰的看出上面的旋转矩阵为"),o(i,{to:"/Graphic/basic/math/matrices.html#%E6%AD%A3%E4%BA%A4%E7%9F%A9%E9%98%B5"},{default:p(()=>[n("正交矩阵")]),_:1}),n("，又因为正交矩阵的逆矩阵等于转置矩阵。")]),d,n(" 最后用这个变换矩阵乘上物体坐标，也就是物体的顶点坐标即可获得顶点在屏幕空间的坐标。 "),h])}const k=t(l,[["render",m],["__file","viewing.html.vue"]]),x=JSON.parse('{"path":"/Graphic/basic/raster/viewing.html","title":"转换","lang":"en-US","frontmatter":{"date":"2020-10-09T18:38:19.000Z","tag":["Graphic"]},"headers":[{"level":2,"title":"视图/相机变换","slug":"视图-相机变换","link":"#视图-相机变换","children":[{"level":3,"title":"定义相机","slug":"定义相机","link":"#定义相机","children":[]},{"level":3,"title":"转换过程","slug":"转换过程","link":"#转换过程","children":[]}]},{"level":2,"title":"模型变换","slug":"模型变换","link":"#模型变换","children":[]},{"level":2,"title":"投影变换","slug":"投影变换","link":"#投影变换","children":[{"level":3,"title":"正交投影","slug":"正交投影","link":"#正交投影","children":[]},{"level":3,"title":"透视投影","slug":"透视投影","link":"#透视投影","children":[]},{"level":3,"title":"视锥","slug":"视锥","link":"#视锥","children":[]}]},{"level":2,"title":"视口变换","slug":"视口变换","link":"#视口变换","children":[]},{"level":2,"title":"最终结果","slug":"最终结果","link":"#最终结果","children":[]}],"git":{"createdTime":1602239899000,"updatedTime":1707214279000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":2},{"name":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2}]},"readingTime":{"minutes":8.36,"words":2508},"filePathRelative":"Graphic/basic/raster/viewing.md","localizedDate":"October 9, 2020","excerpt":"\\n<p>转换是一个三维场景中的物体变化到屏幕二维空间上的一个过程，这个过程大致如下：</p>\\n<figure><img src=\\"https://banming-1254083583.cos.ap-chengdu.myqcloud.com/graphic/basic/raster/viewing/20201202203902.png\\" alt=\\"\\" tabindex=\\"0\\" loading=\\"lazy\\"><figcaption></figcaption></figure>\\n<p>我们常说的<strong>MVP矩阵</strong>转换。</p>\\n<ul>\\n<li><strong>M</strong>odeling : 模型变换</li>\\n<li><strong>V</strong>iew : 视图/相机变换，也就是图中的Camera transformation</li>\\n<li><strong>P</strong>rojection : 投影变换</li>\\n</ul>"}');export{k as comp,x as data};
