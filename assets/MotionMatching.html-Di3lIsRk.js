import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as n,b as a,a as e,o as t}from"./app-DjCCowVD.js";const s={},c=e('<h1 id="code-vs-data-driven-displacement" tabindex="-1"><a class="header-anchor" href="#code-vs-data-driven-displacement"><span>Code vs Data Driven Displacement</span></a></h1><p>原文地址：https://theorangeduck.com/page/code-vs-data-driven-displacement</p><h2 id="definitions" tabindex="-1"><a class="header-anchor" href="#definitions"><span>Definitions</span></a></h2><h3 id="the-simulation-object" tabindex="-1"><a class="header-anchor" href="#the-simulation-object"><span>The Simulation Object</span></a></h3><p>把手柄输入转化为预测要移动的物体。</p>',5),l=e(`<div class="language-c++ line-numbers-mode" data-ext="c++" data-title="c++"><pre class="language-c++"><code>vec3 desired_velocity_update(
    const vec3 gamepadstick_left,
    const float camera_azimuth,
    const quat simulation_rotation,
    const float fwrd_speed,
    const float side_speed,
    const float back_speed)
{
    // Find stick position in world space by rotating using camera azimuth
    vec3 global_stick_direction = quat_mul_vec3(
        quat_from_angle_axis(camera_azimuth, vec3(0, 1, 0)), gamepadstick_left);
    
    // Find stick position local to current facing direction
    vec3 local_stick_direction = quat_inv_mul_vec3(
        simulation_rotation, global_stick_direction);
    
    // Scale stick by forward, sideways and backwards speeds
    vec3 local_desired_velocity = local_stick_direction.z &gt; 0.0 ?
        vec3(side_speed, 0.0f, fwrd_speed) * local_stick_direction :
        vec3(side_speed, 0.0f, back_speed) * local_stick_direction;
    
    // Re-orientate into the world space
    return quat_mul_vec3(simulation_rotation, local_desired_velocity);
}
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="the-character-entity" tabindex="-1"><a class="header-anchor" href="#the-character-entity"><span>The Character Entity</span></a></h3><p>这就是玩家可以看到角色。角色的移动数据是来自动画切片，这种方式叫作数据驱动。</p><p>动画切片：https://github.com/ubisoft/ubisoft-laforge-animation-dataset</p><h2 id="simulation-bone" tabindex="-1"><a class="header-anchor" href="#simulation-bone"><span>Simulation Bone</span></a></h2><p>模拟骨骼是给模拟对象使用的，用来代表移动旋转。</p><h2 id="character-controller" tabindex="-1"><a class="header-anchor" href="#character-controller"><span>Character Controller</span></a></h2><h2 id="synchronization" tabindex="-1"><a class="header-anchor" href="#synchronization"><span>Synchronization</span></a></h2><p>有两种方式：</p><ul><li>直接使用模拟物体同步到角色：会出现滑步</li><li>由数据驱动模拟物体：这会造成延迟感</li></ul><p>那么想到的方式就是直接混合这两者。</p><h2 id="adjustment" tabindex="-1"><a class="header-anchor" href="#adjustment"><span>Adjustment</span></a></h2>`,12);function o(d,r){return t(),n("div",null,[c,a(` <video controls="" muted="" width="640" height="360">
  <source src="/media/uploads/CodeVsDataDriven/SimulationObject.m4v" type="video/mp4">
</video> `),l])}const v=i(s,[["render",o],["__file","MotionMatching.html.vue"]]),u=JSON.parse('{"path":"/Animation/MotionMatching.html","title":"Code vs Data Driven Displacement","lang":"en-US","frontmatter":{"date":"2023-02-28T08:40:18.000Z","tag":"Animation"},"headers":[{"level":2,"title":"Definitions","slug":"definitions","link":"#definitions","children":[{"level":3,"title":"The Simulation Object","slug":"the-simulation-object","link":"#the-simulation-object","children":[]},{"level":3,"title":"The Character Entity","slug":"the-character-entity","link":"#the-character-entity","children":[]}]},{"level":2,"title":"Simulation Bone","slug":"simulation-bone","link":"#simulation-bone","children":[]},{"level":2,"title":"Character Controller","slug":"character-controller","link":"#character-controller","children":[]},{"level":2,"title":"Synchronization","slug":"synchronization","link":"#synchronization","children":[]},{"level":2,"title":"Adjustment","slug":"adjustment","link":"#adjustment","children":[]}],"git":{"createdTime":1677544818000,"updatedTime":1707212040000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":4},{"name":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2}]},"readingTime":{"minutes":0.92,"words":277},"filePathRelative":"Animation/MotionMatching.md","localizedDate":"February 28, 2023","excerpt":"\\n<p>原文地址：https://theorangeduck.com/page/code-vs-data-driven-displacement</p>\\n<h2>Definitions</h2>\\n<h3>The Simulation Object</h3>\\n<p>把手柄输入转化为预测要移动的物体。</p>\\n<!-- <video controls=\\"\\" muted=\\"\\" width=\\"640\\" height=\\"360\\">\\n  <source src=\\"/media/uploads/CodeVsDataDriven/SimulationObject.m4v\\" type=\\"video/mp4\\">\\n</video> -->"}');export{v as comp,u as data};
