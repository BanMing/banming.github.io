import{_ as e}from"./plugin-vue_export-helper-x3n3nnut.js";import{o as a,c as i,b as r}from"./app-f8zbahFJ.js";const t="/assets/epub_36698085_27-OfFxsMu9.jpg",o="/assets/epub_36698085_28-WREu9BcU.jpg",c="/assets/epub_36698085_29-ybd4_K0T.jpg",n="/assets/epub_36698085_30-Jw4wQ7dK.jpg",l={},s=r('<h1 id="vector" tabindex="-1"><a class="header-anchor" href="#vector" aria-hidden="true">#</a> Vector</h1><p>实列网站：https://gabormakesgames.com/blog_vectors.html</p><p>因为浮点数比较计算会有不精确的时候，我们使用一个 <code>epsilon = 0.000001f</code> 的特定数值来比较。</p><h2 id="interpolation" tabindex="-1"><a class="header-anchor" href="#interpolation" aria-hidden="true">#</a> Interpolation</h2><p>计算出两个点之间的某一个位置</p><h3 id="lerp" tabindex="-1"><a class="header-anchor" href="#lerp" aria-hidden="true">#</a> lerp</h3><p>把两点之间的距离归一化得到一个插值<code>t</code></p><ul><li><code>t</code> = 0 ：插值结果为起点</li><li><code>t</code> = 1 ：插值结果为终点</li><li>0 &lt; <code>t</code> &lt; 1 ：插值结果为中间</li></ul><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="slerp" tabindex="-1"><a class="header-anchor" href="#slerp" aria-hidden="true">#</a> slerp</h3><p>以弧度值来做插值（spherical linear interpolation），与线性插值的对比如下：</p><figure><img src="'+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在我们知道了两个点之间的角度时，我们可以用以下公式来求插值结果：</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="nlerp" tabindex="-1"><a class="header-anchor" href="#nlerp" aria-hidden="true">#</a> nlerp</h3><p>他的插值移动速度不是固定的，而是要更快一些。就是把线性插值再做一次归一化。对比如下：</p><figure><img src="'+n+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="generally" tabindex="-1"><a class="header-anchor" href="#generally" aria-hidden="true">#</a> generally</h3><p><code>nlerp</code>是一个好的选择优于<code>slerp</code>。</p>',19),d=[s];function p(h,g){return a(),i("div",null,d)}const u=e(l,[["render",p],["__file","Vectors.html.vue"]]);export{u as default};
