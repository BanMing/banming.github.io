import{_ as l}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as p,f as n,g as i,h as t,j as o,r,o as g}from"./app-Di6dUGFy.js";const s="/assets/2025-08-20-20-54-43-0K43lu59.png",c="/assets/2025-08-20-22-06-21-BFssVrRq.png",m="/assets/2025-08-20-21-09-17-BwZVyAJw.png",d="/assets/2025-08-20-21-38-06-Ca_Bt5Tb.png",u="/assets/2025-08-20-21-39-30-CCBc5Dem.png",f="/assets/2025-08-20-21-45-14-B0cN786n.png",h="/assets/2025-08-20-21-47-17-y8_SogTc.png",y="/assets/2025-08-20-21-50-16-CcrU1p4Q.png",b="/assets/2025-08-20-21-52-04-B1PTc2Rg.png",_="/assets/2025-08-20-21-55-52-Cg5Cc_CO.png",I="/assets/2025-08-20-22-01-10-38VErDt4.png",U="/assets/2025-08-20-22-02-40-Bl-9w4T7.png",C="/assets/2025-08-20-22-25-21-C1HfXu__.png",P="/assets/2025-08-20-22-24-29-CUujkWs4.png",z="/assets/2025-08-20-22-34-05-CadlWjtg.png",x="/assets/2025-08-20-22-40-21-CPASAvVv.png",G="/assets/2025-11-28-02-22-50-Dnfy4g_r.png",w="/assets/2025-11-28-02-49-08-srmPpI_j.png",v="/assets/2025-11-28-02-49-51-q77dr_Lc.png",A="/assets/2025-11-27-23-57-46-BIIKb4KW.png",S="/assets/2025-11-28-01-25-47-DhFlhe_h.png",W="/assets/2025-11-28-01-27-07-CZeP24US.png",D="/assets/2025-11-28-01-35-03-sW_25sZE.png",B="/assets/2025-11-28-01-37-23-Bq-Vazhb.png",L="/assets/2025-11-28-01-38-15-CW3vfOVr.png",k="/assets/2025-11-28-00-54-05-BEr9j3TN.png",M="/assets/2025-11-28-02-13-16-BPZ74pa5.png",T="/assets/2025-11-28-10-38-51-Buvb7Vgm.png",V="/assets/2025-11-28-10-39-37-CzCoQ3YX.png",E="/assets/2025-11-28-10-40-24-zWOQmdIA.png",F="/assets/2025-11-28-14-21-10-BWz1yvqz.png",R="/assets/2025-11-28-10-41-11-BZSlvRhs.png",j="/assets/2025-11-28-01-56-55-vZa_zRHe.png",N="/assets/2025-11-28-01-58-02-BV8--XUB.png",H="/assets/2025-11-28-01-59-46-Bs0ne5Ru.png",K="/assets/2025-11-28-02-17-56-Cq_3dgaP.png",O="/assets/2025-11-28-02-15-56-C65D30zN.png",q="/assets/2025-11-28-02-14-05-D6G85PBq.png",X="/assets/2025-11-28-02-24-56-BDH1S4PP.png",Z="/assets/2025-11-28-02-28-04-Baf1Sy5D.png",J="/assets/2025-11-28-02-34-55-DCKIOHe7.png",Q="/assets/2025-11-28-02-31-29-Ddqi8LGJ.png",Y="/assets/2025-11-28-02-14-45-DYHlzOnM.png",$="/assets/2025-11-28-02-41-14-iFdt00FM.png",aa="/assets/2025-11-28-02-43-19-B4h0-Jap.png",ia="/assets/2025-11-28-14-23-30-BtnUI46R.png",ta="/assets/2025-11-28-10-59-23-Ckjdsr0d.png",ea="/assets/2025-11-28-02-51-47-B9f7XMUE.png",na="/assets/2025-11-28-02-52-53-0zFipE-X.png",oa="/assets/2025-11-28-02-53-45-0bzHkDcw.png",sa="/assets/2025-11-28-02-55-16-CYYfz8uW.png",la="/assets/2025-11-28-02-55-55-m0r6aBpq.png",pa="/assets/2025-11-28-02-57-46-C-cL2Twb.png",ra="/assets/2025-11-28-02-58-19-DcpwB4TP.png",ga="/assets/2025-11-28-02-59-07-VlAwqQlJ.png",ca="/assets/2025-11-28-03-00-07-CpD9nR96.png",ma="/assets/111-FJdk-BIJ.png",da="/assets/222-DVjqDiyK.png",ua="/assets/2025-11-28-10-55-04-BiU4kpc8.png",fa="/assets/2025-11-28-10-56-51-B1HfEhza.png",ha="/assets/2025-11-28-10-58-21-DJ280Vkm.png",ya="/assets/2025-11-28-10-44-52-Dh1f2XRn.png",ba="/assets/2025-11-28-03-01-07-CCqQRiRL.png",_a="/assets/2025-11-28-03-01-51-wWXi7Ln0.png",Ia={};function Ua(Ca,a){const e=r("VPIcon");return g(),p("div",null,[a[4]||(a[4]=n('<h1 id="common-ui" tabindex="-1"><a class="header-anchor" href="#common-ui"><span>Common UI</span></a></h1><p><a href="https://www.youtube.com/watch?v=80flMwKhhcY" target="_blank" rel="noopener noreferrer">UE5 - Common UI Guide: A Complete Guide to Inputs &amp; Widgets</a></p><h2 id="setup" tabindex="-1"><a class="header-anchor" href="#setup"><span>Setup</span></a></h2><p>打开插件：</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>Project Setting</code>设置窗口为<code>CommonGameViewportClinet</code></p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="input-setting" tabindex="-1"><a class="header-anchor" href="#input-setting"><span>Input Setting</span></a></h2><p>在Project Setting中可以设置不同平台中的输入设置</p><figure><img src="'+m+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><a href="https://thoseawesomeguys.com/prompts/" target="_blank" rel="noopener noreferrer">免费按键图标下载</a></p><hr><p>首先新建一个输入数据表：</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在该表中新建4个按键行为：</p><figure><img src="'+u+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里可以键盘和手柄上对应的按键和图片，其中的<code>Gamepad Input Overrides</code>可以设置其他手柄对应的按键。</p><hr><p>接着创建<code>InputData</code>：</p><figure><img src="'+f+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>默认有设置对应的<code>InputActionTable</code>，这个表中几乎有所有按键的设置，如果需要可以直接复制其中的选项到我们新建的表即可。</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在<code>Project Setting</code>中就可以设置输入数据：</p><figure><img src="'+y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><hr><p>接着创建<code>Controller Data</code>:</p><figure><img src="'+b+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>该数据是设置不同平台的不同设配的控制数据，这里PC就可以创建两个：</p><figure><img src="'+_+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>设置按键与图片：</p><figure><img src="'+I+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在设置<code>Gamepad Name</code>时，需要和<code>Project Setting</code>中对应平台的<code>Default Gamepad Name</code>一致：</p><figure><img src="'+U+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这里改不了名字<code>Gamepad Name</code>，这个是定义在<code>DataDrivenPlatformInfo.ini</code>文件中的。</p><hr><h2 id="common-ui-widget" tabindex="-1"><a class="header-anchor" href="#common-ui-widget"><span>Common UI Widget</span></a></h2><p>创建UI：</p><figure><img src="'+C+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+P+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="common-user-widget" tabindex="-1"><a class="header-anchor" href="#common-user-widget"><span>Common User Widget</span></a></h3><figure><img src="'+z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="common-activatable-widget" tabindex="-1"><a class="header-anchor" href="#common-activatable-widget"><span>Common Activatable Widget</span></a></h3><figure><img src="'+x+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="lyra-ui" tabindex="-1"><a class="header-anchor" href="#lyra-ui"><span>Lyra UI</span></a></h2><p>该项目将<code>Lyra</code>中UI模块提取出独立成插件，以便于添加到不同项目中。这篇文档主要讲解如何将该插件接入项目以及一些说明。</p><h3 id="setup-1" tabindex="-1"><a class="header-anchor" href="#setup-1"><span>Setup</span></a></h3><p>打开插件：</p><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p><code>Project Setting</code>设置：</p><ul><li><img src="'+G+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li><img src="'+w+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li><img src="'+v+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></li><li>需要配置输入和默认UIPolicy,具体配置在下文中。</li></ul><p>测试场景：/All/Plugins/GameCommonUIBase/MainMenu</p><h3 id="widget" tabindex="-1"><a class="header-anchor" href="#widget"><span>Widget</span></a></h3><figure><img src="'+A+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>GameUIMessagingSubsystem管理GameUIPolicy，GameUIPolicy决定使用什么样的PrimaryGameLayout，接着PrimaryGameLayout会有多个Layer，每个Layer是一个Switcher，用于控制当前Layer下面显示什么Panel。</p><h4 id="gameuimanagersubsystem" tabindex="-1"><a class="header-anchor" href="#gameuimanagersubsystem"><span>GameUIManagerSubsystem</span></a></h4><p>GameUIManager的主要作用就是负责UIPolicy的加载与切换,同时在玩家加入游戏时（本地多人）可以调用NotifyPlayerAdded等函数执行一些操作，并且调用UIPolicy中对应的方法。</p><p>同时每帧都会设置所有玩家的PrimaryGameLayout和HUD的可见性同步。</p><h4 id="gameuipolicy" tabindex="-1"><a class="header-anchor" href="#gameuipolicy"><span>GameUIPolicy</span></a></h4><p>GameUIPolicy的工作，一言以蔽之就是根据本地玩家的状态（添加、删除或销毁）和本地多人交互的模式（单人、轮换和多人），来决定将RootLayout向视口加入或删除。并且向外提供一些get函数。 另外需要注意UCLASS宏内的Within = GameUIManagerSubsystem说明GameUIPolicy只能由GameUIManagerSubsystem的实例创建，不能单独创建。</p><p>需要在Project Setting中配置：</p><figure><img src="'+S+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="primarygamelayout" tabindex="-1"><a class="header-anchor" href="#primarygamelayout"><span>PrimaryGameLayout</span></a></h4><p>PrimaryGameLayout负责Layer的注册，以及Widget到Layer的push和remove。此外还有布尔类型的值bIsDormant和相关函数，用于给GameUIPolicy判断本地玩家的RootLayout是否显示在屏幕上。</p><p>PrimaryGameLayout就是一个UCommonUserWidget。</p><p>当前默认的布局如下：</p><figure><img src="'+W+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>GameLayer是游戏内UI,类似于HUD,通常用于显示游戏状态，即生命条、武器槽等。</li><li>GameMenu是游戏内的菜单，即背包等。</li><li>Menu是游戏菜单，例如游戏开始界面、设置界面等。</li><li>Modal是游戏弹窗,例如保存游戏或者更改游戏设置时弹窗的确定弹窗之类。</li></ul><p>每个层就是一个UCommonActivatableWidgetStack，内部包含了一个Switcher，将Panel添加到Layer时，会将Panel添加到Switcher里，再通过设置switcher的index来切换Panel。</p><p>每一个Layer对应着一个GameplayTag：</p><figure><img src="'+D+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>将Panel加到Layer中使用：</p><figure><img src="'+B+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>将Panel移除Layer使用：</p><figure><img src="'+L+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="split-screen" tabindex="-1"><a class="header-anchor" href="#split-screen"><span>Split Screen</span></a></h4><p>Lyra中为了实现分屏UI，设计了GameUIPolicy和PrimaryGameLayout。这里可以简单理解：</p><ul><li>在多人游戏且在同一台机器上运行时，UI的规则是GameUIPolicy A，每一个玩家有一个PrimaryGameLayout A，也就是UI布局。</li><li>在单人游戏时，UI的规则GameUIPolicy B。现在的玩家的UI布局就是PrimaryGameLayout B</li></ul><p>这样有些抽象，可以看下图：</p><figure><img src="'+k+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>由此可以知道一个玩家对应自己UI布局，在项目中使用LocalPlayer来定义的玩家信息。</p><p>根据不同玩家加载不同的UI布局触发流程：</p><ul><li>UGameUIGameInstance::AddLocalPlayer 有本地玩家加入到游戏</li><li>UGameUIManagerSubsystem::NotifyPlayerAdded</li><li>UGameUIPolicy::NotifyPlayerAdded 监听本地玩家控制器设置</li><li>AGameUIPlayerController::ReceivedPlayer 本地玩家控器设置完成</li><li>UGameUILocalPlayer::OnPlayerControllerSet 触发委托</li><li>UGameUIPolicy::CreateLayoutWidget 创建布局UI（PrimaryGameLayout）</li><li>UGameUIPolicy::AddLayoutToViewport 添加布局UI到视窗</li></ul><p>所以需要需要将以下文件中的实现复制到项目中对应的文件中去：</p><ul><li>GameUILocalPlayer</li><li>GameUIGameInstance</li><li>GameUIPlayerController</li></ul><p>同时需要在Project Setting和GameMode中设置对应。</p><p>值得注意的是如果游戏不需要分屏UI这种功能时，GameUIPolicy是可以不需要的，在游戏开始时直接将PrimaryGameLayout加载的视窗渲染即可。</p><h4 id="panel" tabindex="-1"><a class="header-anchor" href="#panel"><span>Panel</span></a></h4><figure><img src="'+M+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>因为Panel都是有Switcher管理的，所以所有的Panel都需要继承UGameUIActivatablePanel，也就是需要继承至UCommonActivatableWidget。这样才能有Switcher控制显示隐藏。</p><h6 id="commonactivatablewidget" tabindex="-1"><a class="header-anchor" href="#commonactivatablewidget"><span>CommonActivatableWidget</span></a></h6><ul><li>CommonActivatableWidget在Create出来后默认是Deactivate状态，需要手动Activate：<br> <img src="'+T+'" alt="" loading="lazy"></li><li>也可以在Details-Activation中勾选Auto Activate，勾选后会在Widget Create后自动Activate，Remove后自动Deactivate。<br> <img src="'+V+'" alt="" loading="lazy"></li><li>CommonActivatableWidget可以覆写OnActivated和OnDeactivated来配置改变Activated状态后的回调：<br> <img src="'+E+'" alt="" loading="lazy"></li><li>必须实现GetDesiredFocusTarget方法，用于激活面板时聚焦那个Widget。当CommonActivatableWidget（及其子类对象）成为主激活控件时，可以在蓝图中通过重写这个函数来设置默认聚焦的控件对象。 <ul><li>请注意: 当勾选了bAutoRestoreFocus时，系统在恢复聚焦时会先检查是否保存了有效的聚焦对象（Widget）。如果该对象不存在，系统才会调用 GetDesiredFocusTarget。</li><li>RequestRefreshFocus 允许在满足特定条件（当前节点是叶节点）的情况下，重新设置焦点到期望的焦点目标，而不需要对每个元素都进行Wrap.</li><li>蓝图：<br><img src="'+F+'" alt="" loading="lazy"></li></ul></li><li>即使CommonActivatableWidget被Collapsed了，如果CommonActivatableWidget没有被Deactivate的话，依然会影响输入路由。</li><li>默认情况下CommonActivatableWidget的Activate与Deactivate是不会影响Widget的Visibility的，可以在Details-Activation中单独配置：<br><img src="'+R+'" alt="" loading="lazy"></li><li>OnHandleBackAction :当CommonActivatableWidget（及其子类对象）被激活为主控件时，通常需要处理返回操作的相关逻辑。为了方便处理返回事件，CommonUI提供了一些配置，当触发返回输入时，可以调用BP_OnHandleBackAction函数来优化返回事件的处理逻辑。这样可以使返回事件的绑定逻辑更加清晰和易于维护。</li></ul><h6 id="slot-panel" tabindex="-1"><a class="header-anchor" href="#slot-panel"><span>Slot Panel</span></a></h6><p>其中有一个特殊的Panel - GameUIHUDLayoutPanel，用于制作游戏中的HUD也就是战斗中UI。特殊点是它使用GameUISlotPointWidget对子Widget进行占位，使用GameplayTag对应子Widget，动态加载不同的子Widget。</p><p>这样做到子Widget和Panel之间的完全解耦。</p><p>其中WBP_GameHUDLayout如下图：</p><figure><img src="'+j+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在GameUISlotPointWidget对应配置：</p><figure><img src="'+N+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>加载GameplayTag对应的widget和卸载：</p><figure><img src="'+H+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>子Widget:</p><figure><img src="'+K+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>最终显示效果：</p><figure><img src="'+O+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>其原理是在GameUISlotPointWidget在构造时，会去执行RebuildWidget方法，在该方法把SlotPointTag注册到GameUISlotSubSystem中，然后存储起来。</p><p>当调用GameUISlotSubSystem::RegisterSlot时，也就是上图。会去查询SlotPointTag是否有GameUISlotPointWidget注册过。如果有就将子widget创建出来。</p><p>值得注意的是，如果没有需要Panel中布局是一定的，内容会根据情况不同的需求时。直接使用完整的panel，做会更加只管一些，不一定非要用这中方式。</p><h6 id="message" tabindex="-1"><a class="header-anchor" href="#message"><span>Message</span></a></h6><figure><img src="'+q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>调用方式：</p><figure><img src="'+X+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>也可以直接调用：</p><ul><li>UGameUIMessagingSubsystem::ShowConfirmation</li><li>UGameUIMessagingSubsystem::ShowError</li></ul><p>需要在Project Setting中配置默认的Panel：</p><figure><img src="'+Z+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="widget-1" tabindex="-1"><a class="header-anchor" href="#widget-1"><span>Widget</span></a></h4><p>在Widget目录下有一些复写的基础控件</p><h6 id="inputactionwidget" tabindex="-1"><a class="header-anchor" href="#inputactionwidget"><span>InputActionWidget</span></a></h6><p>一般会配合着按键使用，作为子Widget放在按键的Widget蓝图中。如果配置Input Actions也就是下图：</p><figure><img src="'+J+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>意味着指定按键对应该触发点击事件。如果不指定就是默认按键触发点击事件。</p><h6 id="button" tabindex="-1"><a class="header-anchor" href="#button"><span>Button</span></a></h6><p>基础按键结构如下：</p><figure><img src="'+Q+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h6 id="tab" tabindex="-1"><a class="header-anchor" href="#tab"><span>Tab</span></a></h6><figure><img src="'+Y+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>设置选项卡配置：</p><figure><img src="'+$+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>每一个选项都要可以设置：</p><ul><li>选项按钮</li><li>选项内容Widget</li></ul><p>需要将内容控制的Switcher注册到选项列表组件中：</p><figure><img src="'+aa+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h4 id="widget-focus" tabindex="-1"><a class="header-anchor" href="#widget-focus"><span>Widget Focus</span></a></h4><figure><img src="'+ia+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="input" tabindex="-1"><a class="header-anchor" href="#input"><span>Input</span></a></h3><p>在Common UI中一定不要使用任何关于Enhanced Input相关的设置，Common UI对Enhanced Input的适配并没有非常的完善。如果Gameplay中使用了Enhanced Input，也会跟UI的输入打架。所以这里就是使用Common Input即可。</p><p>在引擎中，处理输入的流程大概如下：</p><figure><img src="'+ta+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>CommonUI主要对上图中的两个红色区域进行了一些自定义输入的扩展。</p><h4 id="setup-2" tabindex="-1"><a class="header-anchor" href="#setup-2"><span>Setup</span></a></h4><ul><li>首先新建一个输入数据表<br><img src="'+ea+'" alt="" loading="lazy"></li><li>在该表中新建4个按键行为<br><img src="'+na+'" alt="" loading="lazy"></li><li>接着创建InputData<br><img src="'+oa+'" alt="" loading="lazy"></li><li>默认有设置对应的InputActionTable，这个表中几乎有所有按键的设置，如果需要可以直接复制其中的选项到我们新建的表即可。<img src="'+sa+'" alt="" loading="lazy"></li><li>在Project Setting中就可以设置输入数据 <br> <img src="'+la+'" alt="" loading="lazy"></li><li>接着创建Controller Data<br><img src="'+pa+'" alt="" loading="lazy"></li><li>该数据是设置不同平台的不同设配的控制数据，这里PC就可以创建两个<br><img src="'+ra+'" alt="" loading="lazy"></li><li>设置按键与图片<br><img src="'+ga+'" alt="" loading="lazy"></li><li>在设置Gamepad Name时，需要和Project Setting中对应平台的Default Gamepad Name一致<br><img src="'+ca+'" alt="" loading="lazy"></li></ul><h4 id="panel-1" tabindex="-1"><a class="header-anchor" href="#panel-1"><span>Panel</span></a></h4><p>GameUIActivatablePanel的InputConfig中可以配置该Widget的输入模式，一旦Widget被Activate，会立刻切换至该Widget的输入模式：</p><figure><img src="'+ma+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>Default：默认是GamePlay和Widget都可以接收输入。</li><li>Game and Menu：同理。</li><li>Game：只有Gameplay能够接收输入，自动隐藏鼠标。</li><li>Menu：只有Widget能够接收输入，对玩家的控制等都会被屏蔽，且会自动显示鼠标。<br> 也可以配置鼠标的捕获模式：</li></ul><figure><img src="'+da+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><ul><li>NoCapture：鼠标不会捕获此窗口的鼠标事件。</li><li>CapturePermanently：此窗口会捕获玩家的鼠标事件。</li><li>CapturePermanentlyIncludingInitialMouseDown：会捕获玩家的鼠标事件，并且除了鼠标点击外还能够处理鼠标按下的事件。</li><li>CaptureDuringMouseDown：鼠标按下触发捕获，抬起releases。</li><li>CaptureDuringRightMouseDown：鼠标右键按下触发捕获。</li></ul><h4 id="commonanalogcursor" tabindex="-1"><a class="header-anchor" href="#commonanalogcursor"><span>CommonAnalogCursor</span></a></h4><p>为了让Gamepad操作沿用鼠标的处理逻辑，CommonUI引入了合成光标FCommonAnalogCursor。它可以通过摇杆/Dpad导航到一个可交互的UI控件上，然后通过点击“EKeys::Virtual_Accept”按键来模拟鼠标左键点击UI</p><p>继承结构：</p><figure><img src="'+ua+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>为了在使用Gamepad操作时显示光标，我们需要执行以下控制台命令：</p><ul><li>CommonUI.AlwaysShowCursor 1</li><li>CommonInput.EnableGamepadPlatformCursor 1</li></ul><p>FAnalogCursor类中实现了摇杆移动多少，鼠标就移动多少的逻辑。对于不想通过导航来选中UI的情况，可以考虑使用这种方式。目前在Common中，它只被当做调试时可用的选项。如果想要了解更多，请在FCommonAnalogCursor中搜索关键字bIsAnalogMovementEnabled</p><p>通过Gamepad按键来模拟鼠标点击的执行流程如下：</p><figure><img src="'+fa+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure>',156)),i("p",null,[a[0]||(a[0]=t("光标位置的更新逻辑在FCommonAnalogCursor")),o(e,{icon:"Tick函数中实现。该逻辑将光标移动到当前聚焦的UI控件的中心点，以方便我们后续通过“EKeys"}),a[1]||(a[1]=t("Virtual_Accept”按键来点击该UI."))]),a[5]||(a[5]=i("p",null,"光标移动到聚焦控件的简化逻辑如下：",-1)),a[6]||(a[6]=i("figure",null,[i("img",{src:ha,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1)),a[7]||(a[7]=i("h4",{id:"default-input",tabindex:"-1"},[i("a",{class:"header-anchor",href:"#default-input"},[i("span",null,"Default Input")])],-1)),a[8]||(a[8]=i("p",null,"如果想要修改默认按键映射，也就是默认手柄确认按键是A，如果想要修改为Y的话。直接修改Input Data中的配置并不能生效。使用Common Input的话，需要修改源码，也就是下面这里：",-1)),a[9]||(a[9]=i("figure",null,[i("img",{src:ya,alt:"",tabindex:"0",loading:"lazy"}),i("figcaption")],-1)),a[10]||(a[10]=i("p",null,"所以并不建议修改默认按键映射。",-1)),i("p",null,[a[2]||(a[2]=t("EKeys")),o(e,{icon:"Virtual_Accept是一个虚拟按键，它在不同的平台可能对应不同的具体按键。默认情况下，EKeys"}),a[3]||(a[3]=t("Virtual_Accept对应于“Gamepad_FaceButton_Bottom”"))]),a[11]||(a[11]=n(`<div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line">InputCoreTypes<span class="token punctuation">.</span>cpp</span>
<span class="line"></span>
<span class="line"><span class="token keyword">const</span> FKey EKeys<span class="token double-colon punctuation">::</span>Virtual_Accept <span class="token operator">=</span> <span class="token class-name">FPlatformInput</span><span class="token double-colon punctuation">::</span><span class="token function">GetGamepadAcceptKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><table><thead><tr><th>ControlType</th><th>EKey</th><th>Key</th><th>File</th></tr></thead><tbody><tr><td>Snoy</td><td>Gamepad_FaceButton_Bottom</td><td>X</td><td></td></tr><tr><td>XBOX360</td><td>Gamepad_FaceButton_Bottom</td><td>A</td><td></td></tr><tr><td>Switch</td><td>Gamepad_FaceButton_Right</td><td>A</td><td>SwitchPlatformInput.cpp</td></tr></tbody></table><h4 id="输入预处理层的扩展" tabindex="-1"><a class="header-anchor" href="#输入预处理层的扩展"><span>输入预处理层的扩展</span></a></h4><p>CommonUI对输入预处理进行了扩展，新增了两个输入预处理类：</p><ul><li><p>FCommonAnalogCursor：这个类主要实现了通过光标模拟鼠标点击UI和使用摇杆滚动UI的逻辑。</p></li><li><p>FCommonEnhancedInputProcessor：用于CommonUI监听和处理输入设备切换事件以及过滤指定输入类型的处理。</p></li><li><p>GameViewportClient层输入的扩展：CommonUI在GameViewportClient层进行了自定义扩展，主要实现了UI绑定按键的功能。它会根据UI的激活状态、UI的层级以及所绑定按键的状态来执行UI的按键绑定逻辑。</p></li></ul><h4 id="display-name" tabindex="-1"><a class="header-anchor" href="#display-name"><span>Display Name</span></a></h4><figure><img src="`+ba+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>在按键上会被设置：</p><figure><img src="'+_a+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><ul><li><a href="https://www.youtube.com/watch?v=u06GAVxyIag" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=u06GAVxyIag</a></li><li><a href="https://www.youtube.com/watch?v=TTB5y-03SnE&amp;t=494s" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=TTB5y-03SnE&amp;t=494s</a></li><li><a href="https://www.youtube.com/watch?v=p_biHD6QZvA" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=p_biHD6QZvA</a></li><li><a href="https://zhuanlan.zhihu.com/p/694293691" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/694293691</a></li><li><a href="https://zhuanlan.zhihu.com/p/18123648655" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/18123648655</a></li><li><a href="https://zhuanlan.zhihu.com/p/598803136" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/598803136</a></li><li><a href="https://zhuanlan.zhihu.com/p/609657844" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/609657844</a></li><li><a href="https://zhuanlan.zhihu.com/p/506574041" target="_blank" rel="noopener noreferrer">https://zhuanlan.zhihu.com/p/506574041</a></li></ul>',11))])}const xa=l(Ia,[["render",Ua],["__file","CommonUI.html.vue"]]),Ga=JSON.parse('{"path":"/GameEngine/Unreal/manual/CommonUI.html","title":"Common UI","lang":"en-US","frontmatter":{"date":"2024-05-08T16:09:29.000Z","tag":["Unreal Engine","UI"]},"git":{"createdTime":1744347206000,"updatedTime":1768292791000,"contributors":[{"name":"ban-ming@foxmail.com","username":"ban-ming@foxmail.com","email":"ban-ming@foxmail.com","commits":2,"url":"https://github.com/ban-ming@foxmail.com"},{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":5,"url":"https://github.com/BanMing"}]},"readingTime":{"minutes":11.43,"words":3430},"filePathRelative":"GameEngine/Unreal/manual/CommonUI.md","localizedDate":"May 8, 2024","excerpt":"\\n<p><a href=\\"https://www.youtube.com/watch?v=80flMwKhhcY\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">UE5 - Common UI Guide: A Complete Guide to Inputs &amp; Widgets</a></p>\\n<h2>Setup</h2>\\n<p>打开插件：</p>\\n<figure><figcaption></figcaption></figure>\\n<p><code>Project Setting</code>设置窗口为<code>CommonGameViewportClinet</code></p>"}');export{xa as comp,Ga as data};
