import{_ as i}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c,a as r,o}from"./app-CpBQXjW7.js";const l={};function n(t,e){return o(),c("div",null,e[0]||(e[0]=[r('<h1 id="receviver-vs-pointer-receviver" tabindex="-1"><a class="header-anchor" href="#receviver-vs-pointer-receviver"><span>Receviver vs Pointer Receviver</span></a></h1><p><a href="https://github.com/golang/go/wiki/CodeReviewComments#receiver-type" target="_blank" rel="noopener noreferrer">官方指导</a>:</p><ul><li>如果接收者是 <code>map</code>,<code>func</code>,<code>chan</code> 这些类型，不要使用指针类型。</li><li>如果接收者是切片或者该方法不会重新分配或切片就不用指针类型。</li><li>如果方法需要改变接收者，接收者必须是一个指针。</li><li>如果接收者是一个含有 <code>sync.Mutex</code> 或者有同步类型的数据结构，那么接收者必须是一个指针，去避免被复制。</li><li>如果接收者是一个大的结构体或者数组，就是使用指针。多大算大？大概是把接收者的所有属性都当参数传递到该方法中。这些参数过多过大就算大。</li><li>当一个方法被调用时，一个值类型的接收者是会被复制传入，所以外部的更新并不会应用到接收者中。如果需要修改源接收者，那么就需要把接收者设置为指针。</li><li>如果接收者是一个 <code>struct</code>,<code>array</code> 或者 <code>slice</code> 其中所有元素都是指针，这些指针可能会被修改。所以接收者最好是指针。</li><li>如果接收者是一个小数组或结构，它自然是一个值类型（例如，类似 time.Time 类型的东西），没有可变字段和指针，或者只是一个简单的基本类型，例如 int 或 string， 值类型接收者是有道理的。 一个值接收者可以减少可以产生的垃圾量； 如果将值传递给值方法，则可以使用堆栈上副本而不是在堆上分配。 （编译器试图巧妙地避免这种分配，但它不可能总是成功。）不要在没有首先分析的情况下选择值接收器类型。</li><li>不要混着用指针和类型传入，在同一个类型中</li><li>最后，当你不知道用啥的时候，就用指针</li></ul>',3)]))}const s=i(l,[["render",n],["__file","recveiver.html.vue"]]),m=JSON.parse('{"path":"/Basic/language/Golang/recveiver.html","title":"Receviver vs Pointer Receviver","lang":"en-US","frontmatter":{"date":"2021-06-27T21:25:44.000Z","tag":["Golang"]},"headers":[],"git":{"createdTime":1624800344000,"updatedTime":1707212881000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":2},{"name":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2}]},"readingTime":{"minutes":1.66,"words":499},"filePathRelative":"Basic/language/Golang/recveiver.md","localizedDate":"June 27, 2021","excerpt":"\\n<p><a href=\\"https://github.com/golang/go/wiki/CodeReviewComments#receiver-type\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">官方指导</a>:</p>\\n<ul>\\n<li>如果接收者是 <code>map</code>,<code>func</code>,<code>chan</code> 这些类型，不要使用指针类型。</li>\\n<li>如果接收者是切片或者该方法不会重新分配或切片就不用指针类型。</li>\\n<li>如果方法需要改变接收者，接收者必须是一个指针。</li>\\n<li>如果接收者是一个含有 <code>sync.Mutex</code> 或者有同步类型的数据结构，那么接收者必须是一个指针，去避免被复制。</li>\\n<li>如果接收者是一个大的结构体或者数组，就是使用指针。多大算大？大概是把接收者的所有属性都当参数传递到该方法中。这些参数过多过大就算大。</li>\\n<li>当一个方法被调用时，一个值类型的接收者是会被复制传入，所以外部的更新并不会应用到接收者中。如果需要修改源接收者，那么就需要把接收者设置为指针。</li>\\n<li>如果接收者是一个 <code>struct</code>,<code>array</code> 或者 <code>slice</code> 其中所有元素都是指针，这些指针可能会被修改。所以接收者最好是指针。</li>\\n<li>如果接收者是一个小数组或结构，它自然是一个值类型（例如，类似 time.Time 类型的东西），没有可变字段和指针，或者只是一个简单的基本类型，例如 int 或 string， 值类型接收者是有道理的。 一个值接收者可以减少可以产生的垃圾量； 如果将值传递给值方法，则可以使用堆栈上副本而不是在堆上分配。 （编译器试图巧妙地避免这种分配，但它不可能总是成功。）不要在没有首先分析的情况下选择值接收器类型。</li>\\n<li>不要混着用指针和类型传入，在同一个类型中</li>\\n<li>最后，当你不知道用啥的时候，就用指针</li>\\n</ul>"}');export{s as comp,m as data};
