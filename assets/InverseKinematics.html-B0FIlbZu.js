import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as s,f as t,o as e}from"./app-NeI3TDSD.js";const p="/assets/epub_36698085_102-C6s8gHFY.jpg",o="/assets/epub_36698085_103-bmpH4VFa.jpg",i="/assets/epub_36698085_104-DsbKjZOF.jpg",l="/assets/epub_36698085_105-C0gEr5OZ.jpg",c="/assets/epub_36698085_106-mRelfksr.jpg",r="/assets/epub_36698085_107-CC11TJv4.jpg",u="/assets/epub_36698085_108-CzcvlD-j.jpg",d="/assets/epub_36698085_109-CXNpnYfQ.jpg",k={};function m(h,n){return e(),s("div",null,n[0]||(n[0]=[t('<h1 id="inverse-kinematics" tabindex="-1"><a class="header-anchor" href="#inverse-kinematics"><span>Inverse Kinematics</span></a></h1><p>逆向运动学是处理一个特殊节点怎么移动到一个世界坐标的位置上的过程。</p><h2 id="understand-how-ccd-ik-works" tabindex="-1"><a class="header-anchor" href="#understand-how-ccd-ik-works"><span>Understand how CCD IK works</span></a></h2><p>CCD是循环旋转下降（Cyclic Coordinate Descent）,这个算法有三个基础概念：</p><ul><li>Goal：目标的世界坐标点</li><li>Ik chain：所有需要移动和选择的节点列表</li><li>End effector：节点列表末端</li></ul><p>这个算法原理很简单，它是一个迭代算法。最开始迭代从节点列表的倒数第二个节点开始，倒数第一个是<code>End effector</code>。我们来解释一次迭代的过程：</p><ul><li>求当前节点到目标点的向量：<code>Joint to Target</code></li><li>求当前节点到末端节点的向量：<code>Joint to Effector</code></li><li>旋转<code>Joint to Effector</code>向量与<code>Jointt to Target</code>同方向</li></ul><p>我们可以看这个图比较清晰，这里画出来两次迭代：<br><img src="'+p+'" alt="" loading="lazy"></p><p>我们需要多次迭代，直到<code>effector</code>离目标点足够接近。</p><h2 id="implement-a-ccd-solver" tabindex="-1"><a class="header-anchor" href="#implement-a-ccd-solver"><span>Implement a CCD solver</span></a></h2><p>迭代的次数需要固定，不能让他无线循环。</p><h2 id="understand-how-fabrik-works" tabindex="-1"><a class="header-anchor" href="#understand-how-fabrik-works"><span>Understand how FABRIK works</span></a></h2><p>FABRILK是正反向运动学（Forward And Backward Reaching Inverse Kinematics），这个算法我们只用位置来计算，不像CCD使用旋转。同样的也需要三个参数：</p><ul><li>Goal：目标的世界坐标点</li><li>Ik chain：所有需要移动和选择的节点列表</li><li>End effector：节点列表末端</li></ul><p>这个算法分成两部分：</p><ul><li>反向迭代：先把最后一个节点开始移动到目标节点位置，然后从后到前依次移动列表中的节点，移动的长度为两节点之间的长度，也就是骨骼的长度；移动的方向是当前节点到下一个节点的方向。</li><li>正向迭代：先把头节点移动到之前反向迭代的位置，然后从前到后依次移动列表中的节点，移动的长度为两节点之间的长度，也就是骨骼的长度；移动的方向是当前节点到上一个节点的位置。</li></ul><p>我们可以看这个图，前两步骤是反向迭代，后三步是正向迭代：<br><img src="'+o+'" alt="" loading="lazy"></p><p>这个算法对于人体动画生成会更加的自然。</p><h2 id="ball-and-socket-constraints" tabindex="-1"><a class="header-anchor" href="#ball-and-socket-constraints"><span>Ball-and-socket constraints</span></a></h2><p>这个办法是对旋转角度的限制，父节点旋转和子节点旋转的角度不能超过多少，超过了就以限制角度为准。形象点说就是跟肩膀关节一样是一样的。像是下面这张图一样，黑色的关节只能在白色这个关节凹陷处旋转。</p><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>以下是伪代码：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">ApplyBallSocketConstraint</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">float</span> limit<span class="token punctuation">)</span> </span>
<span class="line"><span class="token punctuation">{</span>    </span>
<span class="line">    quat parentRot <span class="token operator">=</span> i <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">?</span> mOffset<span class="token punctuation">.</span>rotation <span class="token operator">:</span><span class="token function">GetWorldTransform</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rotation<span class="token punctuation">;</span></span>
<span class="line">    quat thisRot <span class="token operator">=</span> <span class="token function">GetWorldTransform</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span>rotation<span class="token punctuation">;</span>    </span>
<span class="line">    vec3 parentDir <span class="token operator">=</span> parentRot <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span>
<span class="line">    vec3 thisDir <span class="token operator">=</span> thisRot <span class="token operator">*</span> <span class="token function">vec3</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span>
<span class="line">    <span class="token keyword">float</span> angle <span class="token operator">=</span> <span class="token double-colon punctuation">::</span><span class="token function">angle</span><span class="token punctuation">(</span>parentDir<span class="token punctuation">,</span> thisDir<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span>
<span class="line">    <span class="token keyword">if</span> <span class="token punctuation">(</span>angle <span class="token operator">&gt;</span> limit <span class="token operator">*</span> QUAT_DEG2RAD<span class="token punctuation">)</span> </span>
<span class="line">    <span class="token punctuation">{</span>        </span>
<span class="line">        vec3 correction <span class="token operator">=</span> <span class="token function">crHoss</span><span class="token punctuation">(</span>parentDir<span class="token punctuation">,</span> thisDir<span class="token punctuation">)</span><span class="token punctuation">;</span>        </span>
<span class="line">        quat worldSpaceRotation <span class="token operator">=</span> parentRot <span class="token operator">*</span><span class="token function">angleAxis</span><span class="token punctuation">(</span>limit <span class="token operator">*</span> QUAT_DEG2RAD<span class="token punctuation">,</span> correction<span class="token punctuation">)</span><span class="token punctuation">;</span>mChain<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rotation <span class="token operator">=</span> worldSpaceRotation <span class="token operator">*</span> <span class="token function">inverse</span><span class="token punctuation">(</span>parentRot<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span>
<span class="line">    <span class="token punctuation">}</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="hinge-constraints" tabindex="-1"><a class="header-anchor" href="#hinge-constraints"><span>Hinge constraints</span></a></h2><p>这个限制是只允许旋转沿着一个特殊的轴的旋转，这个像肘和膝盖，跟我们生活中的铰链一样。<br><img src="`+l+`" alt="" loading="lazy"></p><p>所以我们只需知道当前节点与父节点的世界空间旋转，用旋转四元数乘以轴法线，并找到两者之间的一个四元数，这个就是我们需要的旋转的量，以下是伪代码：</p><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">void</span> <span class="token function">ApplyHingeSocketConstraint</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">,</span> vec3axis<span class="token punctuation">)</span> </span>
<span class="line"><span class="token punctuation">{</span>    </span>
<span class="line">    Transform joint <span class="token operator">=</span> <span class="token function">GetWorldTransform</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    </span>
<span class="line">    Transform parent <span class="token operator">=</span> <span class="token function">GetWorldTransform</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    </span>
<span class="line">    vec3 currentHinge <span class="token operator">=</span> joint<span class="token punctuation">.</span>rotation <span class="token operator">*</span> axis<span class="token punctuation">;</span>    </span>
<span class="line">    vec3 desiredHinge <span class="token operator">=</span> parent<span class="token punctuation">.</span>rotation <span class="token operator">*</span> axis<span class="token punctuation">;</span>    </span>
<span class="line">    mChain<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rotation <span class="token operator">=</span> mChain<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>rotation <span class="token operator">*</span> <span class="token function">fromToRotation</span><span class="token punctuation">(</span>currentHinge<span class="token punctuation">,</span> desiredHinge<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"><span class="token punctuation">}</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h2 id="understand-where-and-how-ik-solvers-fit-into-an-animation-pipeline" tabindex="-1"><a class="header-anchor" href="#understand-where-and-how-ik-solvers-fit-into-an-animation-pipeline"><span>Understand where and how IK solvers fit into an animation pipeline</span></a></h2><p>有两种常使用IK的地方：手的位置和脚的位置。<br> 有两个常见的问题在我们做IK解决方案时：</p><ul><li>What happens if the up motion is too far away?</li><li>At what point in the animation cycle can we interpolate between pinned and non-pinned positions?</li></ul><p>我们举一个简单的计算脚部IK的例子：</p><ul><li>从髋关节（Hip）出射出一条射线A到脚踝（Ankle） <ul><li>射线碰撞到物体，碰撞点作为IK节点列表的当前目标点</li><li>没有发生碰撞，脚踝就作为当前目标点</li></ul></li><li>同样从髋关节（Hip）出射出一条射线B，不对射线B做长度限制 <ul><li>射线检测碰到物体，碰撞点作为未来的目标点</li><li>没有发生碰撞，把未来的目标点作为当前的目标点</li></ul></li></ul><p>如果我们单纯直接使用目标点</p><ul><li>只用当前目标点：角色的脚可能会突然弹到地面</li><li>只用未来目标点：角色的脚只会在地面拖着</li></ul><p>所以我们需要做插值：</p><ul><li>当角色的脚在碰撞点上，使用使用未来目标点</li><li>当角色的脚在碰撞点下，使用当前目标点</li></ul><h3 id="finding-the-foot-goals" tabindex="-1"><a class="header-anchor" href="#finding-the-foot-goals"><span>Finding the foot goals</span></a></h3><p>我们从髋关节（hip）下面一点发出直的射线到角色脚踝下面一点。射线的方向是髋关节到脚踝。</p><figure><img src="`+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果有碰撞，碰撞点就为目标点，没有目标点就是脚踝的位置。需要注意的是，我们改变的位置是脚踝而不是脚底板，所以如果有碰撞点，需要把目标点上移一段距离，如图 ：</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="interpolating-the-foot-goals" tabindex="-1"><a class="header-anchor" href="#interpolating-the-foot-goals"><span>Interpolating the foot goals</span></a></h3><p>对于插值，我们需要知道是对什么插值，是对那两个值插值，是对动画切片中的腿的位置和IK射线检测计算出来腿的位置做插值，首先需要知道腿当前是属于那个阶段：</p><ul><li>在地面上</li><li>被提起来</li><li>悬挂</li><li>正在被放置</li></ul><p>不同的阶段使用插值比例是不一样的，如果当前腿的位置是在地面上，我们就直接可以使用动画切片的位置；如果腿不在地面上，我们就需要让腿回来地面上，这时就需要使用IK计算出来腿的位置在哪里。</p><p>这样一来我们就可以清晰知道插值的边界是哪里，当脚离开地面数值就为0，然后脚在地面时数值就为1。这个脚的位置数据是直接使用的动画切片的位置来做判断。我们可以使用一个曲线来线性来画出来，把当前动画化切片的播放时间单位话，整个切片时间就是0到1.<br><img src="'+u+'" alt="" loading="lazy"></p><h3 id="vertical-character-placement" tabindex="-1"><a class="header-anchor" href="#vertical-character-placement"><span>Vertical character placement</span></a></h3><p>IK拉伸和普通动画切片的比较：<br><img src="'+d+'" alt="" loading="lazy"><br> 在垂直方向，需要把脚稍微向下一段距离，这样可以让IK系统避免拉伸。</p><h3 id="ik-pass" tabindex="-1"><a class="header-anchor" href="#ik-pass"><span>IK Pass</span></a></h3><p>复制当前姿势的节点到IK解决系统中。对于每一只腿，复制髋关节的世界坐标到IK系统的根节点里。复制膝盖的本地坐标到节点1。复制脚踝的本地坐标到节点2。然后运行IK解决。</p><h3 id="foot-alignment" tabindex="-1"><a class="header-anchor" href="#foot-alignment"><span>Foot alignment</span></a></h3>',51)]))}const v=a(k,[["render",m],["__file","InverseKinematics.html.vue"]]),b=JSON.parse('{"path":"/Animation/gameOpenGL/InverseKinematics.html","title":"Inverse Kinematics","lang":"en-US","frontmatter":{"date":"2022-06-11T20:51:36.000Z","tag":"Animation","order":12},"git":{"createdTime":1654951896000,"updatedTime":1707215246000,"contributors":[{"name":"wupeng","username":"wupeng","email":"ban-ming@foxmail.com","commits":3,"url":"https://github.com/wupeng"},{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":3,"url":"https://github.com/BanMing"},{"name":"wupeng","username":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":3,"url":"https://github.com/wupeng"}]},"readingTime":{"minutes":5.64,"words":1693},"filePathRelative":"Animation/gameOpenGL/InverseKinematics.md","localizedDate":"June 11, 2022","excerpt":"\\n<p>逆向运动学是处理一个特殊节点怎么移动到一个世界坐标的位置上的过程。</p>\\n<h2>Understand how CCD IK works</h2>\\n<p>CCD是循环旋转下降（Cyclic Coordinate Descent）,这个算法有三个基础概念：</p>\\n<ul>\\n<li>Goal：目标的世界坐标点</li>\\n<li>Ik chain：所有需要移动和选择的节点列表</li>\\n<li>End effector：节点列表末端</li>\\n</ul>\\n<p>这个算法原理很简单，它是一个迭代算法。最开始迭代从节点列表的倒数第二个节点开始，倒数第一个是<code>End effector</code>。我们来解释一次迭代的过程：</p>"}');export{v as comp,b as data};
