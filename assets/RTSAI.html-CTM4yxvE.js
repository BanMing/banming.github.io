import{_ as e}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as i,a as n,o as l}from"./app-hZX7V9xq.js";const s="/assets/20211210144409-Cn-tc0b5.png",t="/assets/20211215155406-VgTaXRTz.png",r="/assets/20211215155939-C9sva-J8.png",p="/assets/20211215155845-8urJpcOy.png",h="/assets/20211214211537-Cy2vF0Zr.png",c="/assets/20211215182111-xkx5cMiB.png",d={};function o(g,a){return l(),i("div",null,a[0]||(a[0]=[n('<h1 id="rts-game-ai" tabindex="-1"><a class="header-anchor" href="#rts-game-ai"><span>RTS Game AI</span></a></h1><figure><img src="'+s+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>是一个自底向上的设计方式做的。</p><h2 id="移动" tabindex="-1"><a class="header-anchor" href="#移动"><span>移动</span></a></h2><h3 id="导航" tabindex="-1"><a class="header-anchor" href="#导航"><span>导航</span></a></h3><p>两层导航：空中、地面</p><p>主要策略为走最少的点</p><h3 id="世界转换" tabindex="-1"><a class="header-anchor" href="#世界转换"><span>世界转换</span></a></h3><p>可视化点，预先配置建筑的转角点与地形的转角点。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>量化是在有建筑创建或是销毁是就会执行 这里执行的重建 GridChangesVisibilityGraphHelper.ModifyVisibilityGraph</p><p>转角会根据寻路单位的体型改变，防止单位被卡住和不能通过。</p><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><figure><img src="'+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><h3 id="流程" tabindex="-1"><a class="header-anchor" href="#流程"><span>流程</span></a></h3><p>先使用射线探测是否可以直接到达目的，不能就是启动寻路，能就直接走到目标点 PathfindingProcessor.EvaluatePathWork</p><p>添加寻路计算到Job线程中执行 PathfindingProcessor.DoPathingWork PathfindingProcessor.PathfindingJobDelegate</p><p>主要使用了 A*算法，先把之前射线检测到的障碍物的转角点先加入Open列表。 VisibilityGraph.FindPath</p><p>然后选出最小预计总花销的节点作为当前节点。 VisibilityGraph.DoPathFind</p><p>判断当前节点是否可以到达起始节点,如果可以则实际使用射线检测判断当前节点是否可以直接到达起始节点。 如果可以直接到达起始节点则把当前节点的上一个节点修改为起点。 VisibilityGraph.CheckOriginConnection</p><p>判断当前节点是否可以直接到达目的地，使用射线检测判断，如果不能直接到达，也就是当前节点与目标点有障碍物，如果有碰撞就更新碰撞的障碍物的转角节点的信息并加入Open列表。 VisibilityGraph.HandleRaycastObstacleHit</p><p>如果当前节点可以直接到达目的地，就直接返回当前节点。不能直接到达则将当前节点移除Open列表，并加入Closed列表。</p><p>根据当前点是在起点的左边还是右边更新当前节点对应的所有连接的节点信息， VisibilityGraph.AccumulateNeighbours 且找出与当前节点所有相连的节点最小总预计花销的点。 VisibilityGraph.ExpandNeighbours</p><p>判断该节点与Open列表中最小的节点，如果新的节点小于Open中的，那么就不需要把所有新发现的节点加入到Open列表中。</p><p>否则在新节点加入Open列表后，找到最小花销点，再次循环更新当前节点。</p><h3 id="细节实现" tabindex="-1"><a class="header-anchor" href="#细节实现"><span>细节实现</span></a></h3><h4 id="节点计算信息" tabindex="-1"><a class="header-anchor" href="#节点计算信息"><span>节点计算信息：</span></a></h4><ul><li>Cost-so-far: 两个节点距离</li><li>Heuristic: 当前节点到目的节点距离</li><li>Open,Closed: 寻路节点状态</li><li>StatusToPathOrigin：位于起点左方右方</li><li>StatusToPathDestination：：位于终点点左方右方</li><li>NeighboursInRightRegion: 右边的连接点</li><li>NeighboursInLeftRegion: 左边的连接点</li></ul><h4 id="左右判断" tabindex="-1"><a class="header-anchor" href="#左右判断"><span>左右判断</span></a></h4><p>这里的左右是使用的转角两边做判断。</p><figure><img src="'+h+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>这个转角是90度圆锥，方向是由中心点到转角点的方向决定。只需要使用起点与圆锥两边分别做点乘即可得到当前转角位于起始点的左边还是右边。</p><h4 id="碰撞检测" tabindex="-1"><a class="header-anchor" href="#碰撞检测"><span>碰撞检测</span></a></h4><p>先把地图网格化，如果格子上有建筑，那么这个格子就会被定义为障碍物，再判断由起点到终点连线上是否有已经被定义为障碍物的格子。</p><p>但是有这种情况，障碍物只有半在格子中</p><figure><img src="'+c+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们只需要计算三角形与射线是否相交，即只需要判断射线与三角形任意两个边是否相交就可以了。在即就是判断线段的两个端点是否在边的两侧。</p><h3 id="特殊处理" tabindex="-1"><a class="header-anchor" href="#特殊处理"><span>特殊处理</span></a></h3><h2 id="行为制定" tabindex="-1"><a class="header-anchor" href="#行为制定"><span>行为制定</span></a></h2><h3 id="建筑-生产单位" tabindex="-1"><a class="header-anchor" href="#建筑-生产单位"><span>建筑 &amp; 生产单位</span></a></h3><h3 id="单位行为树" tabindex="-1"><a class="header-anchor" href="#单位行为树"><span>单位行为树</span></a></h3><h3 id="单位技能" tabindex="-1"><a class="header-anchor" href="#单位技能"><span>单位技能</span></a></h3><p>在AIGroupAbilityActivationAttributes配置当前阵营的所有单位的技能，</p><p>同样是规则系统，满足执行条件就分配行为树中去执行</p><h3 id="任务系统" tabindex="-1"><a class="header-anchor" href="#任务系统"><span>任务系统</span></a></h3><h2 id="策略" tabindex="-1"><a class="header-anchor" href="#策略"><span>策略</span></a></h2><h3 id="团队行为" tabindex="-1"><a class="header-anchor" href="#团队行为"><span>团队行为</span></a></h3><h3 id="influence-map" tabindex="-1"><a class="header-anchor" href="#influence-map"><span>Influence Map</span></a></h3>',48)]))}const m=e(d,[["render",o],["__file","RTSAI.html.vue"]]),b=JSON.parse('{"path":"/Gameplay/AI/RTSAI.html","title":"RTS Game AI","lang":"en-US","frontmatter":{"date":"2021-12-14T22:14:04.000Z","tag":["Game AI"],"feed":false,"seo":false},"headers":[{"level":2,"title":"移动","slug":"移动","link":"#移动","children":[{"level":3,"title":"导航","slug":"导航","link":"#导航","children":[]},{"level":3,"title":"世界转换","slug":"世界转换","link":"#世界转换","children":[]},{"level":3,"title":"流程","slug":"流程","link":"#流程","children":[]},{"level":3,"title":"细节实现","slug":"细节实现","link":"#细节实现","children":[]},{"level":3,"title":"特殊处理","slug":"特殊处理","link":"#特殊处理","children":[]}]},{"level":2,"title":"行为制定","slug":"行为制定","link":"#行为制定","children":[{"level":3,"title":"建筑 & 生产单位","slug":"建筑-生产单位","link":"#建筑-生产单位","children":[]},{"level":3,"title":"单位行为树","slug":"单位行为树","link":"#单位行为树","children":[]},{"level":3,"title":"单位技能","slug":"单位技能","link":"#单位技能","children":[]},{"level":3,"title":"任务系统","slug":"任务系统","link":"#任务系统","children":[]}]},{"level":2,"title":"策略","slug":"策略","link":"#策略","children":[{"level":3,"title":"团队行为","slug":"团队行为","link":"#团队行为","children":[]},{"level":3,"title":"Influence Map","slug":"influence-map","link":"#influence-map","children":[]}]}],"git":{"createdTime":1639491244000,"updatedTime":1707213711000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":4},{"name":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2}]},"readingTime":{"minutes":3.14,"words":943},"filePathRelative":"Gameplay/AI/RTSAI.md","localizedDate":"December 14, 2021"}');export{m as comp,b as data};
