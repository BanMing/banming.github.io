import{_ as t}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as a,f as n,o as r}from"./app-m9mnr41q.js";const o={};function i(s,e){return r(),a("div",null,e[0]||(e[0]=[n('<h1 id="优化" tabindex="-1"><a class="header-anchor" href="#优化"><span>优化</span></a></h1><h2 id="字典gc" tabindex="-1"><a class="header-anchor" href="#字典gc"><span>字典GC</span></a></h2><p>当枚举和结构体为字典索引时，调用<code>Contain</code>方法是会拆箱装箱，则会出现GC。解决方案：</p><ul><li>把枚举转成int类型</li><li>结构体继承IEquatable接口，然后在创建一个继承IEqualityComparer的类用来对结构体作比较。把比较类实例化一个全局变量，在字典初始化时把全局比较工具对象传入字典即可。</li></ul><p><a href="https://blog.csdn.net/qq_36576410/article/details/87909947" target="_blank" rel="noopener noreferrer">https://blog.csdn.net/qq_36576410/article/details/87909947</a><br><a href="https://answer.uwa4d.com/question/59f716c0727b4a5d10c6dfef" target="_blank" rel="noopener noreferrer">https://answer.uwa4d.com/question/59f716c0727b4a5d10c6dfef</a><br><a href="https://stackoverflow.com/questions/50303424/why-is-dictionary-containskey-tostring-causing-gc-alloc" target="_blank" rel="noopener noreferrer">https://stackoverflow.com/questions/50303424/why-is-dictionary-containskey-tostring-causing-gc-alloc</a><br><a href="https://forum.unity.com/threads/solved-question-about-dictionary-any-vs-dictionary-containskey.589939/" target="_blank" rel="noopener noreferrer">https://forum.unity.com/threads/solved-question-about-dictionary-any-vs-dictionary-containskey.589939/</a></p>',5)]))}const d=t(o,[["render",i],["__file","Optimize.html.vue"]]),p=JSON.parse('{"path":"/Basic/language/CSharp/Optimize.html","title":"优化","lang":"en-US","frontmatter":{"date":"2022-11-18T18:36:00.000Z","tag":["C#","Optimization"]},"git":{"createdTime":1668767760000,"updatedTime":1707212881000,"contributors":[{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":3,"url":"https://github.com/BanMing"},{"name":"wupeng","username":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2,"url":"https://github.com/wupeng"}]},"readingTime":{"minutes":0.47,"words":142},"filePathRelative":"Basic/language/CSharp/Optimize.md","localizedDate":"November 18, 2022","excerpt":"\\n<h2>字典GC</h2>\\n<p>当枚举和结构体为字典索引时，调用<code>Contain</code>方法是会拆箱装箱，则会出现GC。解决方案：</p>\\n<ul>\\n<li>把枚举转成int类型</li>\\n<li>结构体继承IEquatable接口，然后在创建一个继承IEqualityComparer的类用来对结构体作比较。把比较类实例化一个全局变量，在字典初始化时把全局比较工具对象传入字典即可。</li>\\n</ul>\\n<p><a href=\\"https://blog.csdn.net/qq_36576410/article/details/87909947\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://blog.csdn.net/qq_36576410/article/details/87909947</a><br>\\n<a href=\\"https://answer.uwa4d.com/question/59f716c0727b4a5d10c6dfef\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://answer.uwa4d.com/question/59f716c0727b4a5d10c6dfef</a><br>\\n<a href=\\"https://stackoverflow.com/questions/50303424/why-is-dictionary-containskey-tostring-causing-gc-alloc\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://stackoverflow.com/questions/50303424/why-is-dictionary-containskey-tostring-causing-gc-alloc</a><br>\\n<a href=\\"https://forum.unity.com/threads/solved-question-about-dictionary-any-vs-dictionary-containskey.589939/\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">https://forum.unity.com/threads/solved-question-about-dictionary-any-vs-dictionary-containskey.589939/</a></p>"}');export{d as comp,p as data};
