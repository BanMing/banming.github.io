import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e as r,f as n,o}from"./app-BtdvNmG-.js";const t={};function i(s,e){return o(),r("div",null,e[0]||(e[0]=[n('<h1 id="motion-graphs" tabindex="-1"><a class="header-anchor" href="#motion-graphs"><span>Motion Graphs</span></a></h1><p>内容来自于<a href="https://research.cs.wisc.edu/graphics/Papers/Gleicher/Mocap/mograph.pdf" target="_blank" rel="noopener noreferrer">这篇论文</a>。在Motion Matching中会使用这里面动画切换的技术。</p><p>动作捕捉的数据很难更改？编辑技术仅对运动的微小更改才可靠。如果数据跟实际使用场景的需求不同，就必须重新补捉，这代价就十分大了。这个是真的么？</p><p>这篇论文的目标是保留动作捕捉的真实感，同时也赋予用户控制和指挥角色的能力。简单来说，就是不需要担心角色是否有正确的动画，这个系统会从列表中选取最符合当前情况的一个动画来播放。</p><p>这篇论文提供了一个方法：把所有的基础动捕动画合成一个数据库，这个数据库叫做<code>Motion Graphs</code>。其主要功能是选择当前需要的动画，且可以自动生成两个动画之间的过渡。</p><p><code>Motion Graphs</code>把动画合成问题转化为以下问题之一选择节点序列或图形寻路。</p><h2 id="related-work" tabindex="-1"><a class="header-anchor" href="#related-work"><span>Related Work</span></a></h2><p><code>Motion Graphs</code>是创建一个连续流式动画序列，而不是去修改任何一个原动画数据。</p><p><code>Motion Graphs</code>是一个自动的<code>move trees</code>。自动生成。</p><h2 id="motion-graph-construction" tabindex="-1"><a class="header-anchor" href="#motion-graph-construction"><span>Motion Graph Construction</span></a></h2><p>一个运动片段被定义为角色参数的定期采样，其中包括根关节的位置和四元数代表每个关节的方向。</p><p>标记初始化动画切片相似的程度，直接混合两个切片得到过渡动画。</p><ul><li>describe our algorithm for detecting a set of candidate transition<br> points</li><li>how we select among these candidate transitions</li><li>how blends are created at the chosen transition points</li><li>how to prune the graph to eliminate problematic edges</li></ul><h3 id="detecting-candidate-transitions" tabindex="-1"><a class="header-anchor" href="#detecting-candidate-transitions"><span>Detecting Candidate Transitions</span></a></h3><p>动捕数据就是：</p><ul><li>Vector：根节点位置</li><li>Quaternion：骨骼节点的旋转</li></ul><p>普通的混合有以下三点问题：</p><ul><li>简单的向量无法解释混合使用到的所有参数。如某些骨骼在混合时，他对结果的影响过大。需要手动添加混合权重来平衡混合。</li><li>运动仅定义为刚性2D坐标变换。</li><li>丝滑的混合不仅需要节点的位置和旋转信息，还需要速度加速度等数据，来做支撑。</li></ul><p>把两个姿势转化为点集合（point clouds），然后求这两个点集中的两个点的距离。</p><p>这里是有点没看明白，他后面求权重用这个距离，然后所有距离的最小值作为权重。没明白。</p><p>最后就怎么转化到了一张图啊，还是2D。</p><h3 id="selecting-transition-points" tabindex="-1"><a class="header-anchor" href="#selecting-transition-points"><span>Selecting Transition Points</span></a></h3><p>设置一个阈值来做过渡</p><h3 id="creating-transitions" tabindex="-1"><a class="header-anchor" href="#creating-transitions"><span>Creating Transitions</span></a></h3><p>如果求到的两个点集合（A,B）的距离能够满足阈值，然后就创建一个从当前帧开始长度为<code>k</code>的两段动画的过渡。首先从2D的转换图上对其动画B。</p><p>然后对节点的位置使用线性插值，对旋转使用球面线性插值。</p><h3 id="pruning-the-graph" tabindex="-1"><a class="header-anchor" href="#pruning-the-graph"><span>Pruning The Graph</span></a></h3><p>不是所有节点都可以从一个节点到另一个节点。所以需要对节点裁剪，这里我理解的是对每个节点做分类，也有就是打上标签。</p><p>把同一标签的节点集合起来做连接。<code>SCC</code>是一组节点的极大集合，使得任意有序节点对<code>(u,v)</code>都存在连接图行走。<code>SCC</code>可以使用<code>Tarjan</code>算法在<code>O(V+E)</code>时间内计算。</p><h2 id="extracting-motion" tabindex="-1"><a class="header-anchor" href="#extracting-motion"><span>Extracting Motion</span></a></h2><h3 id="converting-graph-walks-to-motion" tabindex="-1"><a class="header-anchor" href="#converting-graph-walks-to-motion"><span>Converting Graph Walks To Motion</span></a></h3><p>动作图上的每个边都是一段动作，图行走对应于通过将这些片段依次放置来生成的动作。</p><h3 id="searching-for-motion" tabindex="-1"><a class="header-anchor" href="#searching-for-motion"><span>Searching For Motion</span></a></h3><p>使用了公式，没看懂。看起来就是求图的最短路径的问题。</p><h3 id="deciding-what-to-ask-for" tabindex="-1"><a class="header-anchor" href="#deciding-what-to-ask-for"><span>Deciding What To Ask For</span></a></h3><h2 id="reference" tabindex="-1"><a class="header-anchor" href="#reference"><span>Reference</span></a></h2><ul><li><a href="https://research.cs.wisc.edu/graphics/Papers/Gleicher/Mocap/mograph.pdf" target="_blank" rel="noopener noreferrer">https://research.cs.wisc.edu/graphics/Papers/Gleicher/Mocap/mograph.pdf</a></li><li><a href="https://github.com/nunosilva800/Motion-Graphs" target="_blank" rel="noopener noreferrer">https://github.com/nunosilva800/Motion-Graphs</a></li><li><a href="https://github.com/maxxgx/motion-graphs/tree/master" target="_blank" rel="noopener noreferrer">https://github.com/maxxgx/motion-graphs/tree/master</a></li><li><a href="https://research.cs.wisc.edu/graphics/Gallery/kovar.vol/MoGraphs/" target="_blank" rel="noopener noreferrer">https://research.cs.wisc.edu/graphics/Gallery/kovar.vol/MoGraphs/</a></li><li><a href="https://www.youtube.com/watch?v=otGinWYXl-8" target="_blank" rel="noopener noreferrer">https://www.youtube.com/watch?v=otGinWYXl-8</a></li></ul>',37)]))}const c=a(t,[["render",i],["__file","MotionGraphs.html.vue"]]),l=JSON.parse('{"path":"/Animation/MotionMatching/MotionGraphs.html","title":"Motion Graphs","lang":"en-US","frontmatter":{},"git":{"createdTime":1726742868000,"updatedTime":1726742868000,"contributors":[{"name":"ban-ming@foxmail.com","username":"ban-ming@foxmail.com","email":"ban-ming@foxmail.com","commits":1,"url":"https://github.com/ban-ming@foxmail.com"}]},"readingTime":{"minutes":3.17,"words":952},"filePathRelative":"Animation/MotionMatching/MotionGraphs.md","localizedDate":"September 19, 2024","excerpt":"\\n<p>内容来自于<a href=\\"https://research.cs.wisc.edu/graphics/Papers/Gleicher/Mocap/mograph.pdf\\" target=\\"_blank\\" rel=\\"noopener noreferrer\\">这篇论文</a>。在Motion Matching中会使用这里面动画切换的技术。</p>\\n<p>动作捕捉的数据很难更改？编辑技术仅对运动的微小更改才可靠。如果数据跟实际使用场景的需求不同，就必须重新补捉，这代价就十分大了。这个是真的么？</p>\\n<p>这篇论文的目标是保留动作捕捉的真实感，同时也赋予用户控制和指挥角色的能力。简单来说，就是不需要担心角色是否有正确的动画，这个系统会从列表中选取最符合当前情况的一个动画来播放。</p>"}');export{c as comp,l as data};
