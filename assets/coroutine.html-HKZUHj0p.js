import{_ as o}from"./plugin-vue_export-helper-x3n3nnut.js";import{r,o as a,c,e,d as t,f as s}from"./app-DBSbKQKi.js";const i={},l=e("h1",{id:"coroutine",tabindex:"-1"},[e("a",{class:"header-anchor",href:"#coroutine","aria-hidden":"true"},"#"),t(" Coroutine")],-1),d=e("p",null,[t("原理： 一个协成方法会在编译的时候，转化成一个类，在使用的时候生成一个对象，使用 "),e("code",null,"DelayedCallManager"),t(" 来调用。这个有点像timermanager那种感觉。 因为一个对象所有在协成中的局部变量都会成为对象中的变量，所以说如果协成不使用 yeild return ，也就不会释放该对象。在使用该协成时我们就是在使用的时候new一个即可，不需要保存下来。 尽量减少使用....或者说把多个协成合并起来， 在使用一个monobehavior中使用了StartCoroutine开启一个协成，我们把该脚本disable了是无法关闭协成的， • 但是我们把该脚本的GameObject设置SetActive（false）时协成会被关掉， • 当然调用 Destroy该脚本也可以关掉， • 也可以直接调用StopCoroutine")],-1),_=e("p",null,"参考：",-1),u={href:"https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity3.html",target:"_blank",rel:"noopener noreferrer"};function m(h,f){const n=r("ExternalLinkIcon");return a(),c("div",null,[l,d,_,e("p",null,[e("a",u,[t("https://docs.unity3d.com/Manual/BestPracticeUnderstandingPerformanceInUnity3.html"),s(n)])])])}const y=o(i,[["render",m],["__file","coroutine.html.vue"]]);export{y as default};
