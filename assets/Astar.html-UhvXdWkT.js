const e=JSON.parse('{"key":"v-6f0f8608","path":"/Gameplay/AI/PathFinding/Astar.html","title":"A*","lang":"en-US","frontmatter":{"date":"2021-11-14T23:09:35.000Z","tag":["Game AI"]},"headers":[{"level":2,"title":"The Problem","slug":"the-problem","link":"#the-problem","children":[]},{"level":2,"title":"The Algorithm","slug":"the-algorithm","link":"#the-algorithm","children":[{"level":3,"title":"Processing the Current Node","slug":"processing-the-current-node","link":"#processing-the-current-node","children":[]},{"level":3,"title":"The Node List","slug":"the-node-list","link":"#the-node-list","children":[]},{"level":3,"title":"Calculating Cost-So-Far for Open and Closed Nodes","slug":"calculating-cost-so-far-for-open-and-closed-nodes","link":"#calculating-cost-so-far-for-open-and-closed-nodes","children":[]},{"level":3,"title":"Terminating the Algorithm","slug":"terminating-the-algorithm","link":"#terminating-the-algorithm","children":[]},{"level":3,"title":"Retrieving the Path","slug":"retrieving-the-path","link":"#retrieving-the-path","children":[]}]},{"level":2,"title":"Pseudo-Code","slug":"pseudo-code","link":"#pseudo-code","children":[{"level":3,"title":"Changes from Dijkstra","slug":"changes-from-dijkstra","link":"#changes-from-dijkstra","children":[]}]},{"level":2,"title":"Data Structure and Interface","slug":"data-structure-and-interface","link":"#data-structure-and-interface","children":[{"level":3,"title":"Pathfinding List","slug":"pathfinding-list","link":"#pathfinding-list","children":[]},{"level":3,"title":"Heuristic Function","slug":"heuristic-function","link":"#heuristic-function","children":[]}]},{"level":2,"title":"Algorithm Performance","slug":"algorithm-performance","link":"#algorithm-performance","children":[]},{"level":2,"title":"Node Array A*","slug":"node-array-a","link":"#node-array-a","children":[{"level":3,"title":"Keeping a Node Array","slug":"keeping-a-node-array","link":"#keeping-a-node-array","children":[]},{"level":3,"title":"Checking if a Node Is in Open or  Closed","slug":"checking-if-a-node-is-in-open-or-closed","link":"#checking-if-a-node-is-in-open-or-closed","children":[]},{"level":3,"title":"The Open List Implementation","slug":"the-open-list-implementation","link":"#the-open-list-implementation","children":[]},{"level":3,"title":"A Variation for Large Graphs","slug":"a-variation-for-large-graphs","link":"#a-variation-for-large-graphs","children":[]}]},{"level":2,"title":"Choosing a Heuristic","slug":"choosing-a-heuristic","link":"#choosing-a-heuristic","children":[{"level":3,"title":"Underestimating Heuristics","slug":"underestimating-heuristics","link":"#underestimating-heuristics","children":[]},{"level":3,"title":"Overstimating Heuristics","slug":"overstimating-heuristics","link":"#overstimating-heuristics","children":[]},{"level":3,"title":"Euclidean Distance","slug":"euclidean-distance","link":"#euclidean-distance","children":[]},{"level":3,"title":"Cluster Heuristic","slug":"cluster-heuristic","link":"#cluster-heuristic","children":[]},{"level":3,"title":"Fill Patterns in A*","slug":"fill-patterns-in-a","link":"#fill-patterns-in-a","children":[]},{"level":3,"title":"Quality of Heuristics","slug":"quality-of-heuristics","link":"#quality-of-heuristics","children":[]}]},{"level":2,"title":"Improving On A*","slug":"improving-on-a","link":"#improving-on-a","children":[]}],"git":{"createdTime":1699280150000,"updatedTime":1707213711000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":3},{"name":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2}]},"readingTime":{"minutes":13.09,"words":3926},"filePathRelative":"Gameplay/AI/PathFinding/Astar.md","localizedDate":"November 14, 2021","excerpt":"<h1> A*</h1>\\n<p>寻路在游戏里的等同于<code>A*</code>算法。跟<code>Dijkstra</code>不一样，<code>A*</code>是用于点对点的路径查询而不是解决图中的最短路径问题。</p>\\n<h2> The Problem</h2>\\n<p>给一个图（一个有向非负权重图）和两个点（开始点和目标点），找到俩个点直接连通的一条最短花费的路径。</p>\\n<h2> The Algorithm</h2>\\n<p>这个算法的工作原理跟<code>Dijkstra</code>差不多。也是使用迭代器来遍历计算。不同的是<code>A*</code>关注的是最有可能导致总体路径最短的节点，而不是到当前最短花销值的节点。这就会产生如果这节点并不是最有可能产生最短路径的节点，那么<code>A*</code>的效率并不如<code>Dijkstra</code>。</p>"}');export{e as data};
