import{_ as a}from"./plugin-vue_export-helper-DlAUqK2U.js";import{e,f as s,o as i}from"./app-BQKKIMAs.js";const o={};function t(r,n){return i(),e("div",null,n[0]||(n[0]=[s(`<h1 id="animnode-base" tabindex="-1"><a class="header-anchor" href="#animnode-base"><span>AnimNode Base</span></a></h1><p>在 Unreal Engine 中，<code>FAnimNode_Base</code> 是动画蓝图（Animation Blueprint）中所有动画节点的基类。它定义了动画节点的基本行为和生命周期。理解 <code>FAnimNode_Base</code> 的生命周期对于开发自定义动画节点或深入理解动画系统的运行机制非常重要。</p><h2 id="如何创建一个新的动画节点" tabindex="-1"><a class="header-anchor" href="#如何创建一个新的动画节点"><span>如何创建一个新的动画节点：</span></a></h2><ul><li>Create a struct derived from FAnimNode_Base - this is your runtime node</li><li>Create a class derived from UAnimGraphNode_Base, containing an instance of your runtime node as a member - this is your visual/editor-only node</li></ul><p><strong>在创建新的<code>AnimGraphNode</code>时，需要在Cpp中实现构造函数，不需要再头文件中添加构造函数的定义。</strong></p><h2 id="生命周期" tabindex="-1"><a class="header-anchor" href="#生命周期"><span>生命周期</span></a></h2><p>以下是 <code>FAnimNode_Base</code> 的生命周期及其关键阶段的详细讲解：</p><hr><h3 id="_1-动画节点的创建和初始化" tabindex="-1"><a class="header-anchor" href="#_1-动画节点的创建和初始化"><span><strong>1. 动画节点的创建和初始化</strong></span></a></h3><h4 id="构造函数" tabindex="-1"><a class="header-anchor" href="#构造函数"><span><strong>构造函数</strong></span></a></h4><ul><li>当动画蓝图被编译或动画节点被创建时，<code>FAnimNode_Base</code> 的构造函数会被调用。</li><li>在这一阶段，动画节点的成员变量会被初始化。</li></ul><h4 id="initialize-anythread" tabindex="-1"><a class="header-anchor" href="#initialize-anythread"><span><strong>Initialize_AnyThread</strong></span></a></h4><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Initialize_AnyThread</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAnimationInitializeContext<span class="token operator">&amp;</span> Context<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>调用时机</strong>：在动画蓝图初始化时调用，通常是在游戏启动或动画蓝图首次被加载时。</li><li><strong>作用</strong>：用于初始化动画节点的内部状态。可以在这里分配资源、初始化变量或设置初始值。</li><li><strong>注意</strong>：这个函数是在任意线程中调用的（可能是游戏线程或工作线程），因此不能访问游戏线程专有的数据。</li></ul><hr><h3 id="_2-动画节点的缓存绑定" tabindex="-1"><a class="header-anchor" href="#_2-动画节点的缓存绑定"><span><strong>2. 动画节点的缓存绑定</strong></span></a></h3><h4 id="cachebones-anythread" tabindex="-1"><a class="header-anchor" href="#cachebones-anythread"><span><strong>CacheBones_AnyThread</strong></span></a></h4><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">CacheBones_AnyThread</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAnimationCacheBonesContext<span class="token operator">&amp;</span> Context<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>调用时机</strong>：在骨骼层级发生变化时调用，例如角色骨骼网格体（Skeletal Mesh）发生变化或骨骼层级被重新构建时。</li><li><strong>作用</strong>：用于缓存骨骼数据或执行与骨骼相关的初始化操作。</li><li><strong>注意</strong>：这个函数也是在任意线程中调用的。</li></ul><hr><h3 id="_3-动画节点的更新" tabindex="-1"><a class="header-anchor" href="#_3-动画节点的更新"><span><strong>3. 动画节点的更新</strong></span></a></h3><h4 id="update-anythread" tabindex="-1"><a class="header-anchor" href="#update-anythread"><span><strong>Update_AnyThread</strong></span></a></h4><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Update_AnyThread</span><span class="token punctuation">(</span><span class="token keyword">const</span> FAnimationUpdateContext<span class="token operator">&amp;</span> Context<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>调用时机</strong>：每帧调用，用于更新动画节点的状态。</li><li><strong>作用</strong>：在这里可以计算动画节点的逻辑，例如混合权重、状态切换、时间轴更新等。</li><li><strong>注意</strong>： <ul><li>这个函数是在任意线程中调用的。</li><li>不能直接修改骨骼变换数据，只能更新节点的内部状态。</li></ul></li></ul><hr><h3 id="_4-动画节点的评估" tabindex="-1"><a class="header-anchor" href="#_4-动画节点的评估"><span><strong>4. 动画节点的评估</strong></span></a></h3><h4 id="evaluate-anythread" tabindex="-1"><a class="header-anchor" href="#evaluate-anythread"><span><strong>Evaluate_AnyThread</strong></span></a></h4><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">Evaluate_AnyThread</span><span class="token punctuation">(</span>FPoseContext<span class="token operator">&amp;</span> Output<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>调用时机</strong>：每帧调用，用于计算动画节点的最终输出（骨骼变换数据）。</li><li><strong>作用</strong>：在这里可以计算骨骼的局部空间变换（<code>FTransform</code>），并将其写入 <code>Output</code> 中。</li><li><strong>注意</strong>： <ul><li>这个函数是在任意线程中调用的。</li><li>输出的骨骼变换数据会被传递给后续的动画节点或最终的角色骨骼网格体。</li><li>与<code>EvaluateComponentSpace_AnyThread</code>之间只需要实现其中一个即可。</li></ul></li></ul><hr><h3 id="_5-动画节点的后处理" tabindex="-1"><a class="header-anchor" href="#_5-动画节点的后处理"><span><strong>5. 动画节点的后处理</strong></span></a></h3><h4 id="gatherdebugdata" tabindex="-1"><a class="header-anchor" href="#gatherdebugdata"><span><strong>GatherDebugData</strong></span></a></h4><div class="language-cpp line-numbers-mode" data-highlighter="prismjs" data-ext="cpp"><pre><code><span class="line"><span class="token keyword">virtual</span> <span class="token keyword">void</span> <span class="token function">GatherDebugData</span><span class="token punctuation">(</span>FNodeDebugData<span class="token operator">&amp;</span> DebugData<span class="token punctuation">)</span><span class="token punctuation">;</span></span>
<span class="line"></span></code></pre><div class="line-numbers" aria-hidden="true" style="counter-reset:line-number 0;"><div class="line-number"></div></div></div><ul><li><strong>调用时机</strong>：在调试动画蓝图时调用。</li><li><strong>作用</strong>：用于收集动画节点的调试信息，例如当前状态、混合权重、输出值等。</li><li><strong>注意</strong>：这个函数通常用于开发调试工具或动画蓝图调试器。</li></ul><hr><h3 id="_6-动画节点的销毁" tabindex="-1"><a class="header-anchor" href="#_6-动画节点的销毁"><span><strong>6. 动画节点的销毁</strong></span></a></h3><h4 id="析构函数" tabindex="-1"><a class="header-anchor" href="#析构函数"><span><strong>析构函数</strong></span></a></h4><ul><li>当动画节点被销毁时（例如动画蓝图被卸载或游戏结束时），<code>FAnimNode_Base</code> 的析构函数会被调用。</li><li>在这一阶段，可以释放动画节点占用的资源。</li></ul><hr><h3 id="生命周期流程图" tabindex="-1"><a class="header-anchor" href="#生命周期流程图"><span><strong>生命周期流程图</strong></span></a></h3><p>以下是 <code>FAnimNode_Base</code> 的生命周期流程图：</p><ol><li><p><strong>创建和初始化</strong></p><ul><li>构造函数</li><li><code>Initialize_AnyThread</code></li></ul></li><li><p><strong>缓存骨骼数据</strong></p><ul><li><code>CacheBones_AnyThread</code></li></ul></li><li><p><strong>每帧更新</strong></p><ul><li><code>Update_AnyThread</code></li></ul></li><li><p><strong>每帧评估</strong></p><ul><li><code>Evaluate_AnyThread</code></li></ul></li><li><p><strong>调试</strong></p><ul><li><code>GatherDebugData</code></li></ul></li><li><p><strong>销毁</strong></p><ul><li>析构函数</li></ul></li></ol><hr><h3 id="关键注意事项" tabindex="-1"><a class="header-anchor" href="#关键注意事项"><span><strong>关键注意事项</strong></span></a></h3><ol><li><p><strong>线程安全性</strong>：</p><ul><li><code>Initialize_AnyThread</code>、<code>CacheBones_AnyThread</code>、<code>Update_AnyThread</code> 和 <code>Evaluate_AnyThread</code> 都是在任意线程中调用的，因此不能直接访问游戏线程专有的数据（例如 <code>UObject</code> 或 <code>AActor</code>）。</li><li>如果需要访问游戏线程专有的数据，可以使用 <code>FAnimNode_Base::GetProxyOnGameThread</code>。</li></ul></li><li><p><strong>性能优化</strong>：</p><ul><li>动画节点的更新和评估是每帧调用的，因此需要确保这些函数的性能开销尽可能低。</li><li>避免在动画节点中进行复杂的计算或频繁的内存分配。</li></ul></li><li><p><strong>自定义动画节点</strong>：</p><ul><li>如果需要开发自定义动画节点，可以继承 <code>FAnimNode_Base</code> 并重写上述生命周期函数。</li><li>例如，可以实现一个自定义的混合节点、状态机节点或物理模拟节点。</li></ul></li></ol><hr><h3 id="总结" tabindex="-1"><a class="header-anchor" href="#总结"><span><strong>总结</strong></span></a></h3><p><code>FAnimNode_Base</code> 的生命周期涵盖了动画节点的创建、初始化、更新、评估和销毁等关键阶段。理解这些阶段的作用和调用时机，可以帮助开发者更好地使用动画蓝图系统，并开发出高效、灵活的自定义动画节点。</p>`,48)]))}const p=a(o,[["render",t],["__file","AnimNodeBase.html.vue"]]),c=JSON.parse('{"path":"/GameEngine/Unreal/animation/AnimNodeBase.html","title":"AnimNode Base","lang":"en-US","frontmatter":{"date":"2024-08-15T18:03:06.000Z","tag":["Unreal Engine","Animation"]},"git":{"createdTime":1740064427000,"updatedTime":1743235961000,"contributors":[{"name":"BanMing","username":"BanMing","email":"ban-ming@foxmail.com","commits":2,"url":"https://github.com/BanMing"}]},"readingTime":{"minutes":4.01,"words":1204},"filePathRelative":"GameEngine/Unreal/animation/AnimNodeBase.md","localizedDate":"August 15, 2024","excerpt":"\\n<p>在 Unreal Engine 中，<code>FAnimNode_Base</code> 是动画蓝图（Animation Blueprint）中所有动画节点的基类。它定义了动画节点的基本行为和生命周期。理解 <code>FAnimNode_Base</code> 的生命周期对于开发自定义动画节点或深入理解动画系统的运行机制非常重要。</p>\\n<h2>如何创建一个新的动画节点：</h2>\\n<ul>\\n<li>Create a struct derived from FAnimNode_Base - this is your runtime node</li>\\n<li>Create a class derived from UAnimGraphNode_Base, containing an instance of your runtime node as a member - this is your visual/editor-only node</li>\\n</ul>"}');export{p as comp,c as data};
