import{_ as n}from"./plugin-vue_export-helper-DlAUqK2U.js";import{c as s,o as e,a}from"./app-DP08si6W.js";const t="/assets/20211114150116-CWRFRLa1.png",i="/assets/20211114153211-Dpy15pzQ.png",o="/assets/20211114174434-DtX6LFQ_.png",c="/assets/20211114180037-cHc2gCUk.png",p="/assets/20211115221210-DncyEEO9.png",l="/assets/20211115223304-CWK7ctWx.png",d="/assets/20211115225413-BQEO05er.png",r="/assets/20211115230825-Cx9lp9gr.png",u={},h=a('<h1 id="a" tabindex="-1"><a class="header-anchor" href="#a"><span>A*</span></a></h1><p>寻路在游戏里的等同于<code>A*</code>算法。跟<code>Dijkstra</code>不一样，<code>A*</code>是用于点对点的路径查询而不是解决图中的最短路径问题。</p><h2 id="the-problem" tabindex="-1"><a class="header-anchor" href="#the-problem"><span>The Problem</span></a></h2><p>给一个图（一个有向非负权重图）和两个点（开始点和目标点），找到俩个点直接连通的一条最短花费的路径。</p><h2 id="the-algorithm" tabindex="-1"><a class="header-anchor" href="#the-algorithm"><span>The Algorithm</span></a></h2><p>这个算法的工作原理跟<code>Dijkstra</code>差不多。也是使用迭代器来遍历计算。不同的是<code>A*</code>关注的是最有可能导致总体路径最短的节点，而不是到当前最短花销值的节点。这就会产生如果这节点并不是最有可能产生最短路径的节点，那么<code>A*</code>的效率并不如<code>Dijkstra</code>。</p><h3 id="processing-the-current-node" tabindex="-1"><a class="header-anchor" href="#processing-the-current-node"><span>Processing the Current Node</span></a></h3><p>我们在当前节点中还是会存有：每个节点的连接，每个连接的花销，以及连接的尾结点。</p><p>额外的我们还需要记录一个值：从起始节点到此节点再到目标的路径的总花销的估计值。这个估计值是两个值得总和：到目前为止当前节点的总花销加上我们丛当前节点到目标的距离的估计。</p><figure><img src="'+t+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图显示了一些节点 在图中的计算值。其中<code>heuristic</code>就是预计当前点到终点需要的花销。这个值不属于当前算法，是由其他程序生成的，暂时不管。</p><h3 id="the-node-list" tabindex="-1"><a class="header-anchor" href="#the-node-list"><span>The Node List</span></a></h3><p>同样的这里还是有两个列表：</p><ul><li>open ：记录已经被发现的点，但是还未被处理的点。在处理点时把该点连接尾的点加入其中。</li><li>closed ：记录已经被处理过的点，处理完该点就把该点加入该列表。</li></ul><p>不像<code>Dijkstra</code>，在每次遍历开始就选最少花销的节点，而是选择预计花销最短的点。</p><h3 id="calculating-cost-so-far-for-open-and-closed-nodes" tabindex="-1"><a class="header-anchor" href="#calculating-cost-so-far-for-open-and-closed-nodes"><span>Calculating Cost-So-Far for Open and Closed Nodes</span></a></h3><p>我们计算当前节点总花销跟<code>Dijkstra</code>是一样的，比较当前节点加上连接的花销与之前尾结点的总花销做比较就可以。</p><p>不同的是，<code>A*</code>可以发现更好的路径在<code>closed</code>列表中。因为每次遍历并不是找的最小花销的。所以在发现更好的路径在<code>closed</code>里时，可以把这个节点的总花销更新了，然后把它再次放入<code>open</code>列表中。</p><figure><img src="'+i+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>我们可以看到上图是已经遍历过几次了。当前节点<code>C</code>,发现起始点到<code>E</code>的总共花销小于之前算出的。我们就可以把<code>E</code>的总花销数值更新了，然后把它加入到<code>open</code>列表中再次计算。这样就可以到达终点<code>G</code>。</p><h3 id="terminating-the-algorithm" tabindex="-1"><a class="header-anchor" href="#terminating-the-algorithm"><span>Terminating the Algorithm</span></a></h3><p>在很多实现中，跟<code>Dijkstra</code>一样，当目标节点在<code>open</code>列表里是最小的节点时，就结束算法。</p><p>但是在<code>A*</code>中，我们每次取出的节点并不是最少花销的节点。所以我们并不能保证取出来的节点生成的路径是最短的路径。</p><p>但是如果我们为了找到最短路径时，反复去查找，那么这样所带来的的性能消耗，跟<code>Dijkstra</code>是差不多的。所以我们需要做的是对预测方法的调整。并且在第一次访问目标节点时终止。</p><h3 id="retrieving-the-path" tabindex="-1"><a class="header-anchor" href="#retrieving-the-path"><span>Retrieving the Path</span></a></h3><p>得到路径后再反序该路径即可。</p><h2 id="pseudo-code" tabindex="-1"><a class="header-anchor" href="#pseudo-code"><span>Pseudo-Code</span></a></h2><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># This structure is used to keep track of the</span>
<span class="token comment"># information we need for each node.</span>
<span class="token keyword">class</span> <span class="token class-name">NodeRecord</span><span class="token punctuation">:</span>
    node<span class="token punctuation">:</span> Node
    connection<span class="token punctuation">:</span> Connection
    costSoFar<span class="token punctuation">:</span> <span class="token builtin">float</span>
    estimatedTotalCost<span class="token punctuation">:</span> <span class="token builtin">float</span>

function pathfindAStar <span class="token punctuation">(</span>graph<span class="token punctuation">:</span> Graph<span class="token punctuation">,</span> 
                        start<span class="token punctuation">:</span> Node<span class="token punctuation">,</span> 
                        end<span class="token punctuation">:</span> Node<span class="token punctuation">,</span> 
                        heuristic<span class="token punctuation">:</span> Heuristic 
                        <span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> Connection<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">:</span>

    <span class="token comment"># Initialize the record for the start node.</span>
    startRecord <span class="token operator">=</span> new NodeRecord<span class="token punctuation">(</span><span class="token punctuation">)</span>
    startRecord<span class="token punctuation">.</span>node <span class="token operator">=</span> start
    startRecord<span class="token punctuation">.</span>connection <span class="token operator">=</span> null
    startRecord<span class="token punctuation">.</span>costSoFar <span class="token operator">=</span> <span class="token number">0</span>
    startRecord<span class="token punctuation">.</span>estimatedTotalCost <span class="token operator">=</span> heuristic<span class="token punctuation">.</span>estimate<span class="token punctuation">(</span>start<span class="token punctuation">)</span>

    <span class="token comment"># Initialize the open and closed lists.</span>
    <span class="token builtin">open</span> <span class="token operator">=</span> new PathfindingList<span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token builtin">open</span> <span class="token operator">+=</span> startRecord

    closed <span class="token operator">=</span> new PathfindingList<span class="token punctuation">(</span><span class="token punctuation">)</span>

    <span class="token comment"># Iterate through processing each node.</span>
    <span class="token keyword">while</span> length<span class="token punctuation">(</span><span class="token builtin">open</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
        <span class="token comment"># Find the smallest element in the open list (using the</span>
        <span class="token comment"># estimatedTotalCost).</span>
        current <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">.</span>smallestElement<span class="token punctuation">(</span><span class="token punctuation">)</span>

        <span class="token comment"># If it is the goal node, then terminate.</span>
        <span class="token keyword">if</span> current<span class="token punctuation">.</span>node <span class="token operator">==</span> goal<span class="token punctuation">:</span>
            <span class="token keyword">break</span>

        <span class="token comment"># Otherwise get its outgoing connections.</span>
        connections <span class="token operator">=</span> graph<span class="token punctuation">.</span>getConnections<span class="token punctuation">(</span>current<span class="token punctuation">)</span>

        <span class="token comment"># Loop through each connection in turn.</span>
        <span class="token keyword">for</span> connection <span class="token keyword">in</span> connections<span class="token punctuation">:</span>
            <span class="token comment"># Get the cost estimate for the end node.</span>
            endNode <span class="token operator">=</span> connection<span class="token punctuation">.</span>getToNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
            endNodeCost <span class="token operator">=</span> current<span class="token punctuation">.</span>costSoFar <span class="token operator">+</span> connection<span class="token punctuation">.</span>getCost<span class="token punctuation">(</span><span class="token punctuation">)</span>

            <span class="token comment"># If the node is closed we may have to skip, or remove it</span>
            <span class="token comment"># from the closed list.</span>
            <span class="token keyword">if</span> closed<span class="token punctuation">.</span>contains<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># Here we find the record in the closed list</span>
                <span class="token comment"># corresponding to the endNode.</span>
                endNodeRecord <span class="token operator">=</span> closed<span class="token punctuation">.</span>find<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span>

                <span class="token comment"># If we didn’t find a shorter route, skip.</span>
                <span class="token keyword">if</span> endNodeRecord<span class="token punctuation">.</span>costSoFar <span class="token operator">&lt;=</span> endNodeCost<span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>

                <span class="token comment"># Otherwise remove it from the closed list.</span>
                closed <span class="token operator">-=</span> endNodeRecord

                <span class="token comment"># We can use the node’s old cost values to calculate</span>
                <span class="token comment"># its heuristic without calling the possibly expensive</span>
                <span class="token comment"># heuristic function.</span>
                endNodeHeuristic <span class="token operator">=</span> endNodeRecord<span class="token punctuation">.</span>estimatedTotalCost <span class="token operator">-</span> 
                endNodeRecord<span class="token punctuation">.</span>costSoFar

            <span class="token comment"># Skip if the node is open and we’ve not found a better</span>
            <span class="token comment"># route.</span>
            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token builtin">open</span><span class="token punctuation">.</span>contains<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token comment"># Here we find the record in the open list</span>
                <span class="token comment"># corresponding to the endNode.</span>
                endNodeRecord <span class="token operator">=</span> <span class="token builtin">open</span><span class="token punctuation">.</span>find<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span>

                <span class="token comment"># If our route is no better, then skip.</span>
                <span class="token keyword">if</span> endNodeRecord<span class="token punctuation">.</span>costSoFar <span class="token operator">&lt;=</span> endNodeCost<span class="token punctuation">:</span>
                    <span class="token keyword">continue</span>
                
                <span class="token comment"># Again, we can calculate its heuristic.</span>
                endNodeHeuristic <span class="token operator">=</span> endNodeRecord<span class="token punctuation">.</span>cost <span class="token operator">-</span>
                endNodeRecord<span class="token punctuation">.</span>costSoFar

            <span class="token comment"># Otherwise we know we’ve got an unvisited node, so make a</span>
            <span class="token comment"># record for it.</span>
            <span class="token keyword">else</span><span class="token punctuation">:</span>
                endNodeRecord <span class="token operator">=</span> new NodeRecord<span class="token punctuation">(</span><span class="token punctuation">)</span>
                endNodeRecord<span class="token punctuation">.</span>node <span class="token operator">=</span> endNode

                <span class="token comment"># We’ll need to calculate the heuristic value using</span>
                <span class="token comment"># the function, since we don’t have an existing record</span>
                <span class="token comment"># to use.</span>
                endNodeHeuristic <span class="token operator">=</span> heuristic<span class="token punctuation">.</span>estimate<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span>

                <span class="token comment"># We’re here if we need to update the node. Update the</span>
                <span class="token comment"># cost, estimate and connection.</span>
                endNodeRecord<span class="token punctuation">.</span>cost <span class="token operator">=</span> endNodeCost
                endNodeRecord<span class="token punctuation">.</span>connection <span class="token operator">=</span> connection
                endNodeRecord<span class="token punctuation">.</span>estimatedTotalCost <span class="token operator">=</span> endNodeCost <span class="token operator">+</span> endNodeHeuristic

            <span class="token comment"># And add it to the open list.</span>
            <span class="token keyword">if</span> <span class="token keyword">not</span> <span class="token builtin">open</span><span class="token punctuation">.</span>contains<span class="token punctuation">(</span>endNode<span class="token punctuation">)</span><span class="token punctuation">:</span>
                <span class="token builtin">open</span> <span class="token operator">+=</span> endNodeRecord

            <span class="token comment"># We’ve finished looking at the connections for the current</span>
            <span class="token comment"># node, so add it to the closed list and remove it from the</span>
            <span class="token comment"># open list.</span>
            <span class="token builtin">open</span> <span class="token operator">-=</span> current
            closed <span class="token operator">+=</span> current

    <span class="token comment"># We’re here if we’ve either found the goal, or if we’ve no more</span>
    <span class="token comment"># nodes to search, find which.</span>
    <span class="token keyword">if</span> current<span class="token punctuation">.</span>node <span class="token operator">!=</span> goal<span class="token punctuation">:</span>
        <span class="token comment"># We’ve run out of nodes without finding the goal, so there’s</span>
        <span class="token comment"># no solution.</span>
        <span class="token keyword">return</span> null

    <span class="token keyword">else</span><span class="token punctuation">:</span>
        <span class="token comment"># Compile the list of connections in the path.</span>
        path <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

        <span class="token comment"># Work back along the path, accumulating connections.</span>
        <span class="token keyword">while</span> current<span class="token punctuation">.</span>node <span class="token operator">!=</span> start<span class="token punctuation">:</span>
            path <span class="token operator">+=</span> current<span class="token punctuation">.</span>connection
            current <span class="token operator">=</span> current<span class="token punctuation">.</span>connection<span class="token punctuation">.</span>getFromNode<span class="token punctuation">(</span><span class="token punctuation">)</span>
    
        <span class="token comment"># Reverse the path, and return it.</span>
        <span class="token keyword">return</span> reverse<span class="token punctuation">(</span>path<span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="changes-from-dijkstra" tabindex="-1"><a class="header-anchor" href="#changes-from-dijkstra"><span>Changes from Dijkstra</span></a></h3><p>这个算法基本和<code>Dijkstra</code>一样。它多了一个检测在<code>closed</code>里的节点是否需要更新并从新计算该节点。同时也额外的计算了预估花销。</p><p>我们可以把每个节点的预估花销缓存起来，这样就不需要每次都重新计算一次。</p><h2 id="data-structure-and-interface" tabindex="-1"><a class="header-anchor" href="#data-structure-and-interface"><span>Data Structure and Interface</span></a></h2><p>其他数据基本都和<code>Dijkstra</code>一样，但是这里多了一个预估到终点的方法。</p><h3 id="pathfinding-list" tabindex="-1"><a class="header-anchor" href="#pathfinding-list"><span>Pathfinding List</span></a></h3><p>用来存储<code>open</code>和<code>close</code>列表，这两个列表对该算法非常重要，这直接关系到算法效率的好坏。这个列表主要有4个操作：</p><ol><li>添加节点到列表</li><li>从列表中移除移除节点</li><li>找到最小的花销的节点</li><li>找到列表中中特殊的节点</li></ol><p>其中3，4是最具有优化空间的。有很多种方式去优化，我们这里使用优先级队列（priority queue）来做优化。</p><h4 id="priority-queue" tabindex="-1"><a class="header-anchor" href="#priority-queue"><span>Priority Queue</span></a></h4><p>最简单的实现是<code>open</code>列表一直都是排序好了的。也就是说列表中的第一个就是我们需要取的数值。</p><p>我们只需要在添加节点时，保证把这个节点放入正确的位置即可。也就是说在添加的时候就按照排序的规则来添加。</p><p>这里我们可以使用链表来做基础的存储数据结构，但是我们在添加时还是需要遍历已有数据来获取正确的索引。</p><p>如果我们这里使用数组来作为基础数据，我们可以使用二分搜索（binary search）来找到插入点。这比使用链表快很多。如果数据量更大的话，这里的提升会更高些。</p><h4 id="priority-heaps" tabindex="-1"><a class="header-anchor" href="#priority-heaps"><span>Priority Heaps</span></a></h4><p>优先堆是一个以数组为基础的树形数据结构。每一个节点都有两个子节点并且子节点的值都比它大。</p><figure><img src="`+o+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>可以看上图，树是一个平衡树，因此没有一个分支比其他任何层次都深超过一个层次。此外，它还从左到右填充了每一层。</p><p>同时这个数也可以很好的映射到内存上。比如：当前节点是<code>i</code>,那么他的子节点的位置就是<code>2i</code>和<code>2i+1</code>。同时也可以使用堆排序，让树保持节点的有序性。取出和添加时间复杂度都是<code>O(logn)</code>，n是列表中元素的个数。</p><h4 id="bucketed-priority-queues" tabindex="-1"><a class="header-anchor" href="#bucketed-priority-queues"><span>Bucketed Priority Queues</span></a></h4><p>分桶优先队列是更复杂的数据结构，它可以对部分数据排序。这个数据结构提供了跨不同操作的混合性能，它对删除增加都可以做到很快。</p><figure><img src="'+c+`" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>要添加到这类优先级队列中，请在桶中进行搜索，以找到节点所在的桶。然后将其添加到桶列表的开头中。</p><p>简单说就是把数据分块，先找需要插入数据属于那个桶，再在桶中排序。这样就减少了循环。</p><h4 id="implementations" tabindex="-1"><a class="header-anchor" href="#implementations"><span>Implementations</span></a></h4><p>简单地说：</p><ul><li>大图，百万级别的节点数，使用分桶优先队列更好</li><li>小图，几千，几万节点的，使用优先堆更好</li></ul><h3 id="heuristic-function" tabindex="-1"><a class="header-anchor" href="#heuristic-function"><span>Heuristic Function</span></a></h3><p>我们可以简单设置预估花销接口如下 ：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Heuristic</span><span class="token punctuation">:</span>
    <span class="token comment"># An estimated cost to reach the goal from the given node.</span>
    function estimate<span class="token punctuation">(</span>node<span class="token punctuation">:</span> Node<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">float</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h4 id="a-heuristic-for-any-goal" tabindex="-1"><a class="header-anchor" href="#a-heuristic-for-any-goal"><span>A Heuristic for Any Goal</span></a></h4><p>由于为世界上每个可能的目标生成不同的启发式函数不方便，因此启发式通常由目标节点参数化。通过这种方式，可以编写一个通用的启发式实现来估计图中任意两个节点之间的距离。改接口差不多是这样：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token keyword">class</span> <span class="token class-name">Heuristic</span><span class="token punctuation">:</span>
    <span class="token comment"># Stores the goal node that this heuristic is estimating for.</span>
    goalNode<span class="token punctuation">:</span> Node

    <span class="token comment"># Estimated cost to reach the stored goal from the given node.</span>
    function estimate<span class="token punctuation">(</span>fromNode<span class="token punctuation">:</span> Node<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">float</span><span class="token punctuation">:</span>
        <span class="token keyword">return</span> estimate<span class="token punctuation">(</span>fromNode<span class="token punctuation">,</span> goalNode<span class="token punctuation">)</span>
    
    <span class="token comment"># Estimated cost to move between any two nodes.</span>
    function estimate<span class="token punctuation">(</span>fromNode<span class="token punctuation">:</span> Node<span class="token punctuation">,</span> toNode<span class="token punctuation">:</span> Node<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">&gt;</span> <span class="token builtin">float</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>然后可以用来在代码中调用路径查找器，例如：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code>pathfindAStar<span class="token punctuation">(</span>graph<span class="token punctuation">,</span> start<span class="token punctuation">,</span> end<span class="token punctuation">,</span> new Heuristic<span class="token punctuation">(</span>end<span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><h4 id="heuristic-speed" tabindex="-1"><a class="header-anchor" href="#heuristic-speed"><span>Heuristic Speed</span></a></h4><p>这个计算是在很底层调用的，所以我们需要时刻注意这个算法的效率。</p><h2 id="algorithm-performance" tabindex="-1"><a class="header-anchor" href="#algorithm-performance"><span>Algorithm Performance</span></a></h2><p>决定<code>A*</code>算法性能好坏主要因数是这几个的数据结构：寻路列表，图和启发式计算。</p><p><code>A*</code>执行的迭代次数由总估计路径成本小于目标的节点数给出。我们叫这个数为<code>l</code>，这个数比<code>Dijkstra</code>中的<code>n</code>要小。通用<code>m</code>代表每个节点平均的 连接数。他的时间复杂度就为<code>O(lm)</code>，空间复杂度也为<code>O(lm)</code>。</p><p>除了<code>Dijkstra</code>对寻路列表和图的性能关注外，我们还添加了启发式函数。在上面的伪代码中，启发式值为每个节点计算一次，然后再重用。尽管如此，这在循环中发生得非常低，以<code>O(l)</code>时间的顺序排列。如果启发式值没有被重用，它将被称为<code>O(lm)</code>次数。</p><h2 id="node-array-a" tabindex="-1"><a class="header-anchor" href="#node-array-a"><span>Node Array A*</span></a></h2><p>在该算法中有一个关键步骤，在列表中搜索与特定节点对应的节点记录</p><h3 id="keeping-a-node-array" tabindex="-1"><a class="header-anchor" href="#keeping-a-node-array"><span>Keeping a Node Array</span></a></h3><p>我们可以使用增加内存的方式来提高运行效率，我需要申请一个拥有所有图中节点的数组。</p><p>如果节点使用整数进行顺序编号，那么我们根本不需要在这两个列表中搜索一个节点。我们可以简单的使用索引号来查找其在数组中的记录。</p><h3 id="checking-if-a-node-is-in-open-or-closed" tabindex="-1"><a class="header-anchor" href="#checking-if-a-node-is-in-open-or-closed"><span>Checking if a Node Is in Open or Closed</span></a></h3><p>当我们检测一个节点是否在<code>open</code>或<code>close</code>,那么就需要遍历列表。我们可以直接在节点信息中加一个类型来存储该节点是什么类型的。</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># The structure used to track the information we need for each node.</span>
<span class="token keyword">class</span> <span class="token class-name">NodeRecord</span><span class="token punctuation">:</span>
    node<span class="token punctuation">:</span> Node
    connection<span class="token punctuation">:</span> Connection
    costSoFar<span class="token punctuation">:</span> <span class="token builtin">float</span>
    estimatedTotalCost<span class="token punctuation">:</span> <span class="token builtin">float</span>
    category<span class="token punctuation">:</span> <span class="token punctuation">{</span>CLOSED<span class="token punctuation">,</span> OPEN<span class="token punctuation">,</span> UNVISITED<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>如果我们使用类型来区分节点，那么我们是可以不需要<code>close</code>这个列表的。</p><h3 id="the-open-list-implementation" tabindex="-1"><a class="header-anchor" href="#the-open-list-implementation"><span>The Open List Implementation</span></a></h3><p>我们不能直接去掉<code>open</code>列表，因为还是需要求得最小的值。但是我们可以把记录改造成链表式，让每个记录点都记录着它后面的一个记录点。这样我们就需要修改节点的数据结构，如下：</p><div class="language-python line-numbers-mode" data-ext="py" data-title="py"><pre class="language-python"><code><span class="token comment"># The structure used to track the information we need for each node.</span>
<span class="token keyword">class</span> <span class="token class-name">NodeRecord</span><span class="token punctuation">:</span>
    node<span class="token punctuation">:</span> Node
    connection<span class="token punctuation">:</span> Connection
    costSoFar<span class="token punctuation">:</span> <span class="token builtin">float</span>
    estimatedTotalCost<span class="token punctuation">:</span> <span class="token builtin">float</span>
    category<span class="token punctuation">:</span> <span class="token punctuation">{</span>CLOSED<span class="token punctuation">,</span> OPEN<span class="token punctuation">,</span> UNVISITED<span class="token punctuation">}</span>
    nextRecordInList<span class="token punctuation">:</span> NodeRecord
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>但是这种实现会造成内存的浪费，大多数节点都不会在列表里。不需要的代码变得更加复杂，主要的优先级队列看起来很难看。</p><p>最好还是独立出一个节点索引的优先队列来解决<code>open</code>列表的优化。</p><h3 id="a-variation-for-large-graphs" tabindex="-1"><a class="header-anchor" href="#a-variation-for-large-graphs"><span>A Variation for Large Graphs</span></a></h3><p>创建图中所有节点的实例是一种非常浪费的内存的。</p><p>这里有两种方式：</p><p>对有指针的语言中，我们可以先创建一个空壳数组，在需要使用那些节点时，当需要节点时，就创建节点。当我们检测一个节点的状态，我们可以直接判断数组中对应的索引的是否有实例。就可以判断节点是否已经被发现。</p><p>对于拥有垃圾回收的语言，我们最好是在关卡加载是就把所有节点实例化出来，不然在每次寻路时都会创建一些垃圾，这反而造成了卡顿。</p><h2 id="choosing-a-heuristic" tabindex="-1"><a class="header-anchor" href="#choosing-a-heuristic"><span>Choosing a Heuristic</span></a></h2><p>更好的启发式方法，可以使<code>A*</code>跑的更快。所以选好了启发式方法可以事半功倍。</p><h3 id="underestimating-heuristics" tabindex="-1"><a class="header-anchor" href="#underestimating-heuristics"><span>Underestimating Heuristics</span></a></h3><p>当我们的预估值低的时候，该算法会跑的久些，但是精确度是高的。如果是最低值也就是低于所有情况，那我们可以获得真正的最短距离。这跟最短路径算法就是一样的。</p><p>所以我们在要求精度高的情况下，就需要选择低预估值。在实际的游戏开发中，我们可以选择一些高预估值的方法，因为游戏中并不需要太大精度值，关键是角色可以到达目标点。</p><h3 id="overstimating-heuristics" tabindex="-1"><a class="header-anchor" href="#overstimating-heuristics"><span>Overstimating Heuristics</span></a></h3><p>如果预估值过高，生成的路径就会更长。</p><p>但是并不意味着得到的路径就是一条不好的路径。如果预估值最多多<code>x</code>，最终的路径的长度也不会多过<code>x</code>。</p><p>高估值可以使的<code>A*</code>运行的更快。</p><h3 id="euclidean-distance" tabindex="-1"><a class="header-anchor" href="#euclidean-distance"><span>Euclidean Distance</span></a></h3><p>两点的距离来做预估值。</p><figure><img src="`+p+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如果寻路的情况是在室内，两点之间就会出现墙壁或是障碍物，这样角色会花一些时间去绕过障碍物找到目标。</p><figure><img src="'+l+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>使用这种方式，要么是最快找到最好的路径，要么就会是严重低预估值。如上图在室内就会走很多次，但是在室外我们可以很快地找到最优路径。</p><h3 id="cluster-heuristic" tabindex="-1"><a class="header-anchor" href="#cluster-heuristic"><span>Cluster Heuristic</span></a></h3><p>把节点分组，然后分别计算组与组之间的预估值。这个计算我们可以在关卡设计时就做好一个查询表，同样分组的也是设计时做。</p><figure><img src="'+d+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>如上图，我们需要从<code>J</code>点到<code>K</code>点。可以发现<code>J</code>点在<code>A</code>组，<code>K</code>点在<code>C</code>组。通过查表可以知道<code>A</code>到<code>C</code>的预值是<code>29</code>。我们就知道在组之间怎么走了，就可以找到每个组的出入点。然后在组点使用距离做预估值来寻路。</p><p>这种做法往往在室内寻路会有奇效。</p><h3 id="fill-patterns-in-a" tabindex="-1"><a class="header-anchor" href="#fill-patterns-in-a"><span>Fill Patterns in A*</span></a></h3><figure><img src="'+r+'" alt="" tabindex="0" loading="lazy"><figcaption></figcaption></figure><p>上图，我们看到在障碍物多时，两种预估值的对比。</p><p>换一个说法就是，我们在执行<code>A*</code>时，预估值（启发式方法）对其影响很大，如果预估方法可以提供大量的地图信息，<code>A*</code>就会执行的更加的块。</p><p>其实我们使用距离来做预估值已经是很好的了。</p><h3 id="quality-of-heuristics" tabindex="-1"><a class="header-anchor" href="#quality-of-heuristics"><span>Quality of Heuristics</span></a></h3><p>很多程序使用<code>A*</code>时只使用了距离来做启发式，这并不是很好的，对寻路的优化来说修改启发式是很好的途径。</p><p>如果你想要优化你的寻路程序，最好的办法就是把寻路的代码过程可视化，这很重要。不要盲目的去修改。</p><h2 id="improving-on-a" tabindex="-1"><a class="header-anchor" href="#improving-on-a"><span>Improving On A*</span></a></h2>',117),m=[h];function v(k,g){return e(),s("div",null,m)}const y=n(u,[["render",v],["__file","Astar.html.vue"]]),N=JSON.parse('{"path":"/Gameplay/AI/PathFinding/Astar.html","title":"A*","lang":"en-US","frontmatter":{"date":"2021-11-14T23:09:35.000Z","tag":["Game AI"]},"headers":[{"level":2,"title":"The Problem","slug":"the-problem","link":"#the-problem","children":[]},{"level":2,"title":"The Algorithm","slug":"the-algorithm","link":"#the-algorithm","children":[{"level":3,"title":"Processing the Current Node","slug":"processing-the-current-node","link":"#processing-the-current-node","children":[]},{"level":3,"title":"The Node List","slug":"the-node-list","link":"#the-node-list","children":[]},{"level":3,"title":"Calculating Cost-So-Far for Open and Closed Nodes","slug":"calculating-cost-so-far-for-open-and-closed-nodes","link":"#calculating-cost-so-far-for-open-and-closed-nodes","children":[]},{"level":3,"title":"Terminating the Algorithm","slug":"terminating-the-algorithm","link":"#terminating-the-algorithm","children":[]},{"level":3,"title":"Retrieving the Path","slug":"retrieving-the-path","link":"#retrieving-the-path","children":[]}]},{"level":2,"title":"Pseudo-Code","slug":"pseudo-code","link":"#pseudo-code","children":[{"level":3,"title":"Changes from Dijkstra","slug":"changes-from-dijkstra","link":"#changes-from-dijkstra","children":[]}]},{"level":2,"title":"Data Structure and Interface","slug":"data-structure-and-interface","link":"#data-structure-and-interface","children":[{"level":3,"title":"Pathfinding List","slug":"pathfinding-list","link":"#pathfinding-list","children":[]},{"level":3,"title":"Heuristic Function","slug":"heuristic-function","link":"#heuristic-function","children":[]}]},{"level":2,"title":"Algorithm Performance","slug":"algorithm-performance","link":"#algorithm-performance","children":[]},{"level":2,"title":"Node Array A*","slug":"node-array-a","link":"#node-array-a","children":[{"level":3,"title":"Keeping a Node Array","slug":"keeping-a-node-array","link":"#keeping-a-node-array","children":[]},{"level":3,"title":"Checking if a Node Is in Open or  Closed","slug":"checking-if-a-node-is-in-open-or-closed","link":"#checking-if-a-node-is-in-open-or-closed","children":[]},{"level":3,"title":"The Open List Implementation","slug":"the-open-list-implementation","link":"#the-open-list-implementation","children":[]},{"level":3,"title":"A Variation for Large Graphs","slug":"a-variation-for-large-graphs","link":"#a-variation-for-large-graphs","children":[]}]},{"level":2,"title":"Choosing a Heuristic","slug":"choosing-a-heuristic","link":"#choosing-a-heuristic","children":[{"level":3,"title":"Underestimating Heuristics","slug":"underestimating-heuristics","link":"#underestimating-heuristics","children":[]},{"level":3,"title":"Overstimating Heuristics","slug":"overstimating-heuristics","link":"#overstimating-heuristics","children":[]},{"level":3,"title":"Euclidean Distance","slug":"euclidean-distance","link":"#euclidean-distance","children":[]},{"level":3,"title":"Cluster Heuristic","slug":"cluster-heuristic","link":"#cluster-heuristic","children":[]},{"level":3,"title":"Fill Patterns in A*","slug":"fill-patterns-in-a","link":"#fill-patterns-in-a","children":[]},{"level":3,"title":"Quality of Heuristics","slug":"quality-of-heuristics","link":"#quality-of-heuristics","children":[]}]},{"level":2,"title":"Improving On A*","slug":"improving-on-a","link":"#improving-on-a","children":[]}],"git":{"createdTime":1636902575000,"updatedTime":1707213711000,"contributors":[{"name":"BanMing","email":"ban-ming@foxmail.com","commits":3},{"name":"wupeng","email":"wupeng_a2484@virtuos.com.cn","commits":2}]},"readingTime":{"minutes":13.09,"words":3926},"filePathRelative":"Gameplay/AI/PathFinding/Astar.md","localizedDate":"November 14, 2021","excerpt":"\\n<p>寻路在游戏里的等同于<code>A*</code>算法。跟<code>Dijkstra</code>不一样，<code>A*</code>是用于点对点的路径查询而不是解决图中的最短路径问题。</p>\\n<h2>The Problem</h2>\\n<p>给一个图（一个有向非负权重图）和两个点（开始点和目标点），找到俩个点直接连通的一条最短花费的路径。</p>\\n<h2>The Algorithm</h2>\\n<p>这个算法的工作原理跟<code>Dijkstra</code>差不多。也是使用迭代器来遍历计算。不同的是<code>A*</code>关注的是最有可能导致总体路径最短的节点，而不是到当前最短花销值的节点。这就会产生如果这节点并不是最有可能产生最短路径的节点，那么<code>A*</code>的效率并不如<code>Dijkstra</code>。</p>"}');export{y as comp,N as data};
